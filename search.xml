<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>English</title>
    <url>/English/</url>
    <content><![CDATA[<hr>
<h1 id="English"><a href="#English" class="headerlink" title="English"></a>English</h1><span id="more"></span>

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1500569811&auto=0&height=66"></iframe>

<h2 id="例句："><a href="#例句：" class="headerlink" title="例句："></a><strong>例句</strong>：</h2><ul>
<li><blockquote>
<p>“None of these programes do that”,says another expert.</p>
<p>“而这些程序都没有做到这一点”另一位专家说。</p>
</blockquote>
</li>
<li><blockquote>
<p>there is no doubt that he is innocent.</p>
<p>毫无疑问，他是无辜的。</p>
</blockquote>
</li>
<li><blockquote>
<p>her proposal met with contnual rejectons.</p>
<p>她的建议一再遭到拒绝。</p>
</blockquote>
</li>
<li><blockquote>
<p>The police decided to investgate further.</p>
<p>警方决定作进一步调查。</p>
</blockquote>
</li>
<li><blockquote>
<p>if ambition is to be well regarded, the rewards of ambition must be deemed worthy of the sacrifices made on ambition’s bealf.</p>
<p>如果雄心想要得到人们的重视，则它带来的回报就必须被认定能低得上为其所做出的牺牲。 </p>
</blockquote>
</li>
</ul>
<hr>
<hr>
<img src="https://raw.githubusercontent.com/apricot502/images/master/img20210323105621.png" style="zoom: 67%;" />

<blockquote>
<p>​        History has proved that rapid[^1] development of individuals of society cannot be separated from the formation of good habit.</p>
<p>历史证明，个人的快速发展离不开社会的进步。 </p>
<p>The picture  above demonstrates[^2] a common situation : in the left picture is a girl who is doing homework and believing that early completion[^3] is better , while the boy in the right picture  is sitting in a sofa,telling himself,”I will not act until the last minute.”</p>
<p>上图展示了一种常见的情况：左图中是一个正在做作业的女孩，她认为提前完成作业更好，而右图中的男孩坐在沙发上，对自己说：“我要到最后一分钟才会行动。”</p>
<p>The artist tried to draw more attention to the formation of good habit.</p>
<p>这位艺术家试图使人们更多地注意养成良好习惯。</p>
<p>​        The critical[^4] role of good habits could be summed up in two aspects.</p>
<p>良好习惯的关键作用可以从两个方面来概括。</p>
<p>First of all, good habit is a crucially[^5] foundational[^6] stone of building the harmonious society. </p>
<p>首先，良好的习惯是构建和谐社会的基石。</p>
<p>Furthermore[^7], we should pour closer attention to the positive significance[^8] of good habit to individual well–being.</p>
<p>此外，我们应该更加关注良好习惯对个人幸福的积极意义。</p>
<p>Without it, one’s life would be deficient[^9] in a critical component[^10].</p>
<p>没有它，一个人的生命将缺乏一个关键的组成部分</p>
<p>One of the most convincing[^11] examples is China: the great rejuvenation[^12] of the Chinese nation is inseparable[^13] from the good study habit. </p>
<p>其中一个最有说服力的例子就是中国：中华民族的伟大复兴离不开善学习习惯。</p>
<p>Therefore, we are required to attach importance to it.</p>
<p>因此，必须引起我们的重视。</p>
<p>​        There is no hesitation that we have plenty[^14] of works to do in the next step. Initially, for the promotion[^15] of this precious spirit, we should not underestimate individual behavior, but gradually accumulate the strength of each individual to maximize its effect. </p>
<p>毫不犹豫，下一步我们还有很多工作要做。最初，对于这种宝贵精神的弘扬，我们不应低估个体的行为，而应逐步积累每个个体的力量，使其效果最大化。</p>
<p>On the other hand, those in high positions should try to find a solution to enhance civic awareness of developing good habit.</p>
<p>另一方面，身居高位者应设法寻找解决办法，增强公民养成良好习惯的意识。</p>
<p>I reckon that these approaches will lay the foundation for its promotion.</p>
<p>我认为这些方法将为它的推广打下基础。</p>
</blockquote>
<blockquote>
<p>pour closer attention to :密切关注</p>
<p>well–being : 幸福</p>
</blockquote>
<p>[^1]: 美 /ˈræpɪd/,英 /ˈræpɪd/    adj. 瞬间的, 短时间内发生的, 迅速的, 快速的, 快捷的</p>
<p>[^2]:美 /ˈdemənstreɪts/,英 /ˈdemənstreɪts/v.    证明, 证实, 论证, 说明, 表达, 表露, 表现, 显露, 示范, 演示demonstrate的第三人称单数<br>[^3]:美 /kəmˈpliːʃn/,英 /kəmˈpliːʃn/          n. 完成, 结束, (房地产等的)完成交易，完成交割<br>[^4]:美 /ˈkrɪtɪkl/,英 /ˈkrɪtɪkl/    adj. 批评的, 批判性的, 挑剔的, 极重要的, 关键的, 至关紧要的, 严重的, 不稳定的, 可能有危险的<br>[^5]:美 /ˈkruʃəlɪ/,英 /ˈkru:ʃɪəlɪ/ad    v. 关键性地<br>[^6]:美 /faʊnˈdeɪʃənəl/,英 /faʊnˈdeɪʃən(ə)l/ad    j. 基本的；基础的；财团的<br>[^7]:美 /ˌfɜːrðərˈmɔːr/,英 /ˌfɜːðəˈmɔː(r)/ad    v. 此外, 而且, 再者<br>[^8]:美 /sɪɡˈnɪfɪkəns/,英 /sɪɡˈnɪfɪkəns/n.     (尤指对将来有影响的)重要性，意义, 意思, 含义<br>[^9]:美 /dɪˈfɪʃnt/,英 /dɪˈfɪʃnt/    adj. 缺乏的, 缺少的, 不足的, 有缺点的, 有缺陷的<br>[^10]:美 /kəmˈpoʊnənt/,英 /kəmˈpəʊnənt/    n. 组成部分, 成分, 部件<br>adj. 成分的, 组成的, 合成的, 构成的<br>[^11]:美 /kənˈvɪnsɪŋ/,英 /kənˈvɪnsɪŋ/    adj. 令人信服的, 有说服力的    v. 使确信, 使相信, 使信服, 说服，劝说(某人做某事)    convince的现在分词<br>[^12]:美 /rɪˌdʒuvəˈneɪʃən/,英 /rɪˌdʒuːvɪˈneɪʃən/    n. 更新, 复苏, 〔生〕复壮, 回春作用<br>[^13]:美 /ɪnˈseprəbl/,英 /ɪnˈseprəbl/    adj. (与某事物)不可分离的，分不开的, 形影不离的    n. 不可分离的事物, 形影不离的好友<br>[^14]:美 /ˈplenti/ ,英 /ˈplenti/pron. 大量, 众多, 充足<br>adv. 大量, 很多, 足够有余, 非常, 十分, 很<br>n. 富裕, 充裕<br>det. 很多, 大量</p>
<p>[^15]:美 /prəˈmoʊʃn/,英 /prəˈməʊʃn/    n.升, 提拔, 晋升, (体育运动队的)晋级，升级, 促销活动, 广告宣传</p>
]]></content>
      <categories>
        <category>En-note</category>
      </categories>
      <tags>
        <tag>en</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/hello-world/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>初遇</category>
      </categories>
      <tags>
        <tag>hello world</tag>
      </tags>
  </entry>
  <entry>
    <title>傅里叶级数及变换</title>
    <url>/%E5%82%85%E9%87%8C%E5%8F%B6%E7%BA%A7%E6%95%B0%E5%8F%8A%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h2 id="三角函数的正交性"><a href="#三角函数的正交性" class="headerlink" title="三角函数的正交性"></a>三角函数的正交性</h2><h3 id="三角函数系"><a href="#三角函数系" class="headerlink" title="三角函数系"></a>三角函数系</h3><p>三角函数系本身是一个集合:</p>
<p>{$0(sin0x),1(cos0x),sinx,cosx,sin2x,cos2x,…,sinnx,cosnx$}</p>
<h3 id="正交性：从三角函数系中任取两个不同的项相乘均等于0"><a href="#正交性：从三角函数系中任取两个不同的项相乘均等于0" class="headerlink" title="正交性：从三角函数系中任取两个不同的项相乘均等于0"></a>正交性：从三角函数系中任取两个不同的项相乘均等于0</h3><p>示例：</p>
<p>$\displaystyle \int^{\pi}_{-\pi}{cosnxsinnxdx}=0$,{$n\in N$}</p>
<p>$\displaystyle \int^{\pi}_{-\pi}{cosnxcosmxdx}=0$,{$n\neq m$}</p>
<p>$\displaystyle \int^{\pi}_{-\pi}{sinnxsinmxdx}=0$,{$n\neq m$}</p>
<h2 id="周期为-2-pi-的函数展开为傅里叶级数"><a href="#周期为-2-pi-的函数展开为傅里叶级数" class="headerlink" title="周期为$2\pi$的函数展开为傅里叶级数"></a>周期为$2\pi$的函数展开为傅里叶级数</h2><p>设有函数$f(x)$,周期T=$2\pi$,即$f(x)=f(x+2\pi)$</p>
<p>则傅里叶级数展开公式为：</p>
<p>$f(x)=$$\displaystyle \sum^{n \to \infty}<em>{n=0}a</em>{n}cosnx+\displaystyle \sum^{n \to \infty}<em>{n=0}b</em>{n}sinnx$                                      （1）</p>
<p>=$a_{0}+\displaystyle \sum^{n \to \infty}<em>{n=1}a</em>{n}cosnx+\displaystyle \sum^{n \to \infty}<em>{n=1}b</em>{n}sinnx  $                                        （2）           </p>
<p>,注意此式子中$a_{0}$跟下面$\frac{a_{0}}{2}$中的$a_{0}$不是同一个$a_{0}$</p>
<p>大多数书籍傅里叶级数展开式为</p>
<p>$f(x)=$$\frac{a_{0}}{2}+\displaystyle \sum^{n \to \infty}<em>{n=1}a</em>{n}cosnx+\displaystyle \sum^{n \to \infty}<em>{n=1}b</em>{n}sinnx$                              （3）</p>
<p>这两个式子的不同之处在与$\frac{a_{0}}{2}$和n从1开始累加，</p>
<ol>
<li>求$a_{0}$，对(2)式两边进行$-\pi到\pi$的积分，则：</li>
</ol>
<p>$\displaystyle \int^{\pi}<em>{-\pi}{f(x)dx}$=$\displaystyle \int^{\pi}</em>{-\pi}{a_{0}dx}$+$\displaystyle \int^{\pi}<em>{-\pi}\displaystyle \sum^{n \to \infty}</em>{n=1}{a_{n} cosnx dx}$+$\displaystyle \int^{\pi}<em>{-\pi}\displaystyle \sum^{n \to \infty}</em>{n=1}{b_{n} sinnx dx}$</p>
<p>其中根据三角函数的正交性：$\displaystyle \int^{\pi}<em>{-\pi}\displaystyle \sum^{n \to \infty}</em>{n=1}{a_{n} cosnx dx}$=0，$\displaystyle \int^{\pi}<em>{-\pi}\displaystyle \sum^{n \to \infty}</em>{n=1}{b_{n} sinnx dx}$=0</p>
<p>求得$a_{0}$=$\frac{1}{2\pi}\displaystyle \int^{\pi}_{-\pi}{f(x)dx}$</p>
<p>则令$a_{0}$=$\frac{1}{\pi}\displaystyle \int^{\pi}_{-\pi}{f(x)dx}$</p>
<p>得到（3）式</p>
<ol start="2">
<li>求$a_{n}$,对（3）式两边同时乘$cosmx$，并对等式两边进行$-\pi到\pi$的积分，则：</li>
</ol>
<p>$\displaystyle \int^{\pi}<em>{-\pi}{f(x)cosmxdx}$=$\displaystyle \int^{\pi}</em>{-\pi}{\frac{a_{0}}{2}cosmxdxdx}$+$\displaystyle \int^{\pi}<em>{-\pi}\displaystyle \sum^{n \to \infty}</em>{n=1}{a_{n} cosnxcosmxdx dx}$+$\displaystyle \int^{\pi}<em>{-\pi}\displaystyle \sum^{n \to \infty}</em>{n=1}{b_{n} sinnxcosmxdx dx}$</p>
<p>其中根据三角函数的正交性：$\displaystyle \int^{\pi}<em>{-\pi}{\frac{a</em>{0}}{2}cosmxdxdx}$=0,$\displaystyle \int^{\pi}<em>{-\pi}\displaystyle \sum^{n \to \infty}</em>{n=1}{b_{n} sinnxcosmxdx dx}$=0</p>
<p>而$\displaystyle \int^{\pi}<em>{-\pi}\displaystyle \sum^{n \to \infty}</em>{n=1}{a_{n} cosnxcosmxdx dx}$中当n=m时$\displaystyle \int^{\pi}<em>{-\pi}\displaystyle a</em>{n}cosnxcosmxdx$=$a_{n}\pi$</p>
<p>所以$a_{n}=\frac{1}{\pi}\displaystyle \int^{\pi}_{-\pi}{f(x)cosnxdx}$</p>
<ol start="3">
<li>求$b_{n}$,对（3）式两边同时乘$sinmx$，并对等式两边进行$-\pi到\pi$的积分，得：</li>
</ol>
<p>$b_{n}$=$\frac{1}{\pi}\displaystyle \int^{\pi}_{-\pi}{f(x)sinnxdx}$</p>
<p>故周期为$2\pi$傅里叶展开式为：</p>
<p>$f(x)=$$\frac{a_{0}}{2}+\displaystyle \sum^{n \to \infty}<em>{n=1}a</em>{n}cosnx+\displaystyle \sum^{n \to \infty}<em>{n=1}b</em>{n}sinnx$            </p>
<p>$a_{0}$=$\frac{1}{\pi}\displaystyle \int^{\pi}_{-\pi}{f(x)dx}$</p>
<p>$a_{n}=\frac{1}{\pi}\displaystyle \int^{\pi}_{-\pi}{f(x)cosnxdx}$</p>
<p>$b_{n}$=$\frac{1}{\pi}\displaystyle \int^{\pi}_{-\pi}{f(x)sinnxdx}$</p>
<h2 id="周期为-2L-的函数展开为傅里叶级数"><a href="#周期为-2L-的函数展开为傅里叶级数" class="headerlink" title="周期为$2L$的函数展开为傅里叶级数"></a>周期为$2L$的函数展开为傅里叶级数</h2><p>函数：$f(t)=f(t+2L)$</p>
<p>换元：x=$\frac{\pi}{L}t$,即t=$\frac{L}{\pi}$</p>
<table>
<thead>
<tr>
<th>t</th>
<th>x</th>
</tr>
</thead>
<tbody><tr>
<td>2L</td>
<td>2$\pi$</td>
</tr>
<tr>
<td>4L</td>
<td>4$\pi$</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
</tr>
</tbody></table>
<p>则$f(t)=f(\frac{L}{\pi})$，令$g(x)=f(\frac{L}{\pi})$</p>
<p>则$g(x)$周期为$2\pi$这样就化成了周期为2$\pi$的傅里叶级数展开</p>
<p>把x=$\frac{\pi}{L}t$代入得</p>
<p>$cosnx=cos\frac{n\pi}{L}t$</p>
<p>$sinnx=sin\frac{n\pi}{L}t$</p>
<p>$g(x)=f(t)$</p>
<p>$\displaystyle \int^{\pi}<em>{-\pi}{xdx}$=$\displaystyle \int^{-L}</em>{L}{xdt}$(看下图)</p>
<table>
<thead>
<tr>
<th>x</th>
<th>t</th>
</tr>
</thead>
<tbody><tr>
<td>-$\pi$</td>
<td>-L</td>
</tr>
<tr>
<td>$\pi$</td>
<td>L</td>
</tr>
</tbody></table>
<p>故：</p>
<p>$g(x)$=$\frac{a_{0}}{2}+\displaystyle \sum^{n \to \infty}<em>{n=1}a</em>{n}cosnx+\displaystyle \sum^{n \to \infty}<em>{n=1}b</em>{n}sinnx$    </p>
<p>==$ f(t)$=$\frac{a_{0}}{2}+\displaystyle \sum^{n \to \infty}<em>{n=1}a</em>{n}cos\frac{n\pi}{L}t+\displaystyle \sum^{n \to \infty}<em>{n=1}b</em>{n}sin\frac{n\pi}{L}t$==</p>
<p>$a_{0}$=$\frac{1}{\pi}\displaystyle \int^{\pi}_{-\pi}{f(x)dx}$</p>
<p>==$a_{0}$=$\frac{1}{L}\displaystyle \int^{L}_{-L}{f(x)dx}$==</p>
<p>$a_{n}=\frac{1}{\pi}\displaystyle \int^{\pi}_{-\pi}{f(x)cosnxdx}$</p>
<p>==$a_{n}=\frac{1}{L}\displaystyle \int^{L}_{-L}{f(x)cos\frac{n\pi}{L}tdt}$==</p>
<p>$b_{n}$=$\frac{1}{\pi}\displaystyle \int^{\pi}_{-\pi}{f(x)sinnxdx}$</p>
<p>==$b_{n}$=$\frac{1}{L}\displaystyle \int^{L}_{-L}{f(x)sin\frac{n\pi}{L}tdt}$==</p>
<p>在工程当中：t从0开始·，周期T=2L,$\omega=\frac{2\pi}{T}$</p>
<p>$\displaystyle \int^{L}<em>{-L}{dt}\Rightarrow\displaystyle \int^{2L}</em>{0}{dt}\Rightarrow\displaystyle \int^{T}_{0}{dt}$</p>
<p>所以：</p>
<p>==$ f(t)$=$\frac{a_{0}}{2}+\displaystyle \sum^{n \to \infty}<em>{n=1}a</em>{n}cosn\omega t+\displaystyle \sum^{n \to \infty}<em>{n=1}b</em>{n}sin\omega t$==</p>
<p>==$a_{0}$=$\frac{2}{T}\displaystyle \int^{T}_{0}{f(x)dx}$==</p>
<p>==$a_{n}=\frac{2}{T}\displaystyle \int^{T}_{0}{f(x)cosn\omega tdt}$==</p>
<p>==$b_{n}$=$\frac{2}{T}\displaystyle \int^{T}_{0}{f(x)sinn\omega tdt}$==</p>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>傅里叶</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy</title>
    <url>/numpy/</url>
    <content><![CDATA[<hr>
<h1 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h1><span id="more"></span>

<h2 id="Numpy的数据结构ndarry"><a href="#Numpy的数据结构ndarry" class="headerlink" title="Numpy的数据结构ndarry"></a>Numpy的数据结构ndarry</h2><p>ndarry:一种多维数组对象</p>
<h3 id="1-ndarray介绍"><a href="#1-ndarray介绍" class="headerlink" title="1.ndarray介绍"></a>1.ndarray介绍</h3><p><strong>ndarray：</strong></p>
<ul>
<li><p>N-dimensional array， N维数组,</p>
</li>
<li><p>一种由相同类型的元素组成的多维数组，元素数量是事先指定好的.</p>
</li>
<li><p>元素的数据类型由dtype（data-type）对象来指定，每个ndarray只有一种dtype类型</p>
</li>
<li><p>大小固定，创建好数组时一旦指定好大小，就不会再发生改变</p>
</li>
</ul>
<p><img src="numpy.assets/image-20210403204412903.png" alt="image-20210403204412903"></p>
<p><strong>ndarry属性:</strong></p>
<ul>
<li>ndim 维度数量</li>
<li>dtype，一个用于说明数组元素数据类型的对象</li>
<li>size，元素总个数，即shape中各数组相乘</li>
</ul>
<p>创建一个三维数组如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#x3D;np.array([[[3.4,5,6,8],[3,2.4,5,7]],[[2.3,4,5,6],[0.9,5,6,1]],[[9,6.7,3,2],[1,3,4,5]]])</span><br><span class="line">a</span><br></pre></td></tr></table></figure>

<p>实例：<img src="https://raw.githubusercontent.com/apricot502/images/master/img20210403210227.png" alt="image-20210403210224915"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 数组维度</span><br><span class="line">a.ndim</span><br></pre></td></tr></table></figure>

<p>实例:</p>
<p><img src="https://raw.githubusercontent.com/apricot502/images/master/img20210403205943.png" alt="image-20210403205941211"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#数组元素类型</span><br><span class="line">a.dtype</span><br></pre></td></tr></table></figure>

<p>实例：<img src="https://raw.githubusercontent.com/apricot502/images/master/img20210403210415.png" alt="image-20210403210413142"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 数组形状</span><br><span class="line">a.shape</span><br></pre></td></tr></table></figure>

<p>实例：<img src="https://raw.githubusercontent.com/apricot502/images/master/img20210403210529.png" alt="image-20210403210528064"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 数组元素总个数</span><br><span class="line">a.size</span><br></pre></td></tr></table></figure>

<p>实例：<img src="https://raw.githubusercontent.com/apricot502/images/master/img20210403210652.png" alt="image-20210403210650997"></p>
<h3 id="2-ndarray的常见创建方式"><a href="#2-ndarray的常见创建方式" class="headerlink" title="2.ndarray的常见创建方式"></a>2.ndarray的常见创建方式</h3>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>ps-工作区</title>
    <url>/ps-%E5%B7%A5%E4%BD%9C%E5%8C%BA/</url>
    <content><![CDATA[<hr>
<h1 id="ps工作区"><a href="#ps工作区" class="headerlink" title="ps工作区"></a>ps工作区</h1><span id="more"></span>

<h2 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h2><h3 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h3><p>1.选择”菜单“&gt;”打开“，切换到文件夹Lessons\Lesson01,再双击01Start.psd。将其打开。</p>
<p>​        这个文件包含背景图像和缎带图像如下图示：</p>
<p><img src="https://raw.githubusercontent.com/apricot502/images/master/img20210413204631.png" alt="image-20210406195703885" style="zoom: 50%;" /><img src="https://raw.githubusercontent.com/apricot502/images/master/img20210413204632.png" alt="image-20210406195754099" style="zoom: 67%;" /></p>
<p>2.点击工具栏面板顶部的双箭头可切换到双栏视图入下图：</p>
<p><img src="https://raw.githubusercontent.com/apricot502/images/master/img20210413204633.png" alt="image-20210406200042452" style="zoom:67%;" /><img src="https://raw.githubusercontent.com/apricot502/images/master/img20210413204634.png" alt="image-20210406200103696"></p>
<blockquote>
<p>提示：可以自定义工具面板——重新排列，删除和添加工具。为此，可按住缩放工具下方的”编辑工具条“图标，并选择”编辑工具栏“。</p>
</blockquote>
<p>3.在工作区底端的状态栏中，最左边列出百分比为图像的当前缩放比例，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/apricot502/images/master/img20210413204635.png" alt="image-20210406200706734"></p>
<p>4.将鼠标指向工具面板中的放大镜按钮，将出现工具提示，指出工具名称（缩放工具）和快捷键（Z），或直接用快捷键alt+鼠标滚轮直接进行缩放。</p>
<p>快捷键</p>
<blockquote>
<p>放大缩小：alt+鼠标滚轮</p>
<p>还原图层：Ctrl+Z</p>
<p>撤回还原编辑：Ctrl+shift+Z</p>
<p>来回切换工具：shift+L</p>
<blockquote>
<p>处理选取（选择选取后的操作）：</p>
<p>取消选区：Ctrl+D</p>
<p>移动选区：Ctrl+鼠标移动</p>
<p>微移选取（每次1像素）：Ctrl+方向键</p>
<p>微移选取（每次10像素）：Ctrl+shift+方向键</p>
</blockquote>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>markdown-1.md</title>
    <url>/markdown-1/</url>
    <content><![CDATA[<hr>
<center><b> markdown—基础一</b></center>

<span id="more"></span>

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=530 height=450 src="//music.163.com/outchain/player?type=0&id=5321532436&auto=0&height=430"></iframe>

<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>1.使用，-标记一级标题跟二级标题</p>
<h1 id="展示一级标题"><a href="#展示一级标题" class="headerlink" title="展示一级标题"></a>展示一级标题</h1><h2 id="使用-表示1-6级标题"><a href="#使用-表示1-6级标题" class="headerlink" title="使用#表示1-6级标题"></a>使用#表示1-6级标题</h2><h3 id="2-段落格式markdown段落没有特殊格式，直接编写就好，段落的换行是使用两个以上空格加上回车。"><a href="#2-段落格式markdown段落没有特殊格式，直接编写就好，段落的换行是使用两个以上空格加上回车。" class="headerlink" title="2.段落格式markdown段落没有特殊格式，直接编写就好，段落的换行是使用两个以上空格加上回车。"></a>2.段落格式markdown段落没有特殊格式，直接编写就好，段落的换行是使用两个以上空格加上回车。</h3><p>段落 </p>
<p>markdown可以使用以下几种字体</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一：*斜体文本*</span><br><span class="line">二：_斜体文本_</span><br><span class="line">三：**粗体文本**</span><br><span class="line">四：__粗体文本__</span><br><span class="line">五：***粗斜体文本***</span><br><span class="line">六：___粗斜体文本___</span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<p>一：<em>斜体文本</em></p>
<p>二：<em>斜体文本</em></p>
<p>三：<strong>粗体文本</strong></p>
<p>四：<strong>粗体文本</strong></p>
<p>五：<em><strong>粗体斜文本</strong></em></p>
<p>六：<em><strong>粗体斜文本</strong></em></p>
<h3 id="3-分隔线"><a href="#3-分隔线" class="headerlink" title="3.分隔线"></a>3.分隔线</h3><p>可以在一行用三个以上的星号，减号，底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">one:***</span><br><span class="line">two: * * *</span><br><span class="line">three:*****</span><br><span class="line">four:- - -</span><br><span class="line">five:-----------</span><br></pre></td></tr></table></figure>

<p>one:</p>
<hr>
<p>two:</p>
<hr>
<p>three:</p>
<hr>
<p>four:</p>
<hr>
<p>five:</p>
<hr>
<h3 id="4-删除线"><a href="#4-删除线" class="headerlink" title="4.删除线"></a>4.删除线</h3><p>在文字两端加上两个波浪线~~</p>
<p>示例：</p>
<p><del>beautiful</del></p>
<h3 id="5-下划线"><a href="#5-下划线" class="headerlink" title="5.下划线"></a>5.下划线</h3><p>下划线可以通过HTML的<u>标签来实现</p>
<p>示例：</p>
<p><u>下划线</u></p>
<h3 id="6-脚注"><a href="#6-脚注" class="headerlink" title="6.脚注"></a>6.脚注</h3><p>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[^要注明的格式]</span><br><span class="line">[^要注明的格式]:文字解说</span><br></pre></td></tr></table></figure>


<p>   示例：啊<a href="%E6%96%87%E5%AD%97%E8%A7%A3%E8%AF%B4">^最帅的人</a></p>
<h3 id="7-列表"><a href="#7-列表" class="headerlink" title="7.列表"></a>7.列表</h3><p>无序列表使用*，+，-作为列表标记，这些标记后面添加一个空格，然后填写内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">one:*空格</span><br><span class="line">two:+空格</span><br><span class="line">three:-空格</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<p>one：</p>
<ul>
<li>第一项</li>
</ul>
<p>two:</p>
<ul>
<li>第二项</li>
</ul>
<p>three：</p>
<ul>
<li>第三项</li>
</ul>
<p>有序列表数字加上[^.]再加上空格</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.&#123;空格&#125;第一项</span><br><span class="line">2.第二项</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<ol>
<li>第一项</li>
<li>第二项</li>
</ol>
<p>列表嵌套：</p>
<p>列表嵌套只需要在子列表的选项前面添加四个空格即可。要跳出列表只需按两次回车键</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.&#123;空格&#125;“文字”+&#123;回车&#125;</span><br><span class="line">&#123;四个空格或tab键&#125;</span><br></pre></td></tr></table></figure>



<p>示例：</p>
<ol>
<li>第一项<ol>
<li>子列表</li>
</ol>
</li>
</ol>
<h3 id="8-区块"><a href="#8-区块" class="headerlink" title="8.区块"></a>8.区块</h3><p>区块引用是在段开头使用[^&gt;]符号，然后后面紧跟着一个空格符号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; &#123;空格&#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<blockquote>
<p>区块</p>
</blockquote>
<p>另外区块可以嵌套，一个[^&gt;]是最外层，两个[^&gt;]符号是第一层嵌套，以此类推：、</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;第一层</span><br><span class="line">&gt;&gt;第二层</span><br><span class="line">&gt;&gt;&gt;第三层</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<blockquote>
<p>first</p>
<blockquote>
<p>second</p>
<blockquote>
<p>third</p>
</blockquote>
</blockquote>
</blockquote>
<p>区块中使用列表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;区块中使用列表</span><br><span class="line">&gt;1.&#123;空格&#125;第一项</span><br><span class="line">&gt;2.&#123;空格&#125;第二项</span><br><span class="line">&gt;+&#123;空格&#125;第三项</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<blockquote>
<p>区块中使用空格</p>
<ol>
<li>第一项</li>
<li>第二项</li>
</ol>
<ul>
<li>第三项</li>
<li>第四项</li>
</ul>
</blockquote>
<p>列表中使用区块</p>
<p>如果要在列表中使用区块，那么就需要在[^&gt;]前添加四个空格的缩进。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*&#123;空格&#125;第一箱</span><br><span class="line">&#123;四个空格或tab键&#125;文字</span><br></pre></td></tr></table></figure>



<p>示例：</p>
<ul>
<li><p>第一项</p>
</li>
<li><blockquote>
<p>文字</p>
</blockquote>
</li>
</ul>
<p>markdown代码：</p>
<h3 id="9-代码"><a href="#9-代码" class="headerlink" title="9.代码"></a>9.代码</h3><p>如果段落内上的一个函数或片段的代码可以用反引号包起来，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;print()&#96;函数</span><br></pre></td></tr></table></figure>

<p><code>print（）</code>函数</p>
<p>代码区块：</p>
<p>代码区块使用四个空格或者一个tab键(){此方法好像无用}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;四个空格或tab&#125;代码</span><br></pre></td></tr></table></figure>

<p>示例；<br>可用方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">​&#96;&#96;&#96;&#123;空格&#125;</span><br></pre></td></tr></table></figure>

<p>示例：略</p>
<p>​    markdown链接：</p>
<p>链接使用方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">one:[链接名称](链接地址)</span><br><span class="line">或者</span><br><span class="line">two:&lt;链接地址&gt;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<p>one:<a href="http://www.baidu.com/">百度</a></p>
<p>two:<a href="http://www.biadu.com/">http://www.biadu.com</a></p>
<h3 id="10-高级链接："><a href="#10-高级链接：" class="headerlink" title="10.高级链接："></a>10.高级链接：</h3><p>可以通过一个变量来设置一个链接，变量赋值在文档末尾进行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这个链接用1作为网址变量[Google][1]</span><br><span class="line">这个链接用run作为网址变量[Baidu][run]&#123;首字母大写&#125;</span><br><span class="line">然后在文档结尾处</span><br><span class="line">[1]:http:&#x2F;&#x2F;www.google.com&#x2F;</span><br><span class="line">[run]:http:&#x2F;&#x2F;www.baidu.com&#x2F;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<p>这个链接用1作为网址变量<a href="http://www.google.com/">Google</a><br>这个链接用run作为网址变量<a href="http://www.baidu.com/">Baidu</a><br>然后在文档结尾处</p>
<p>markdown图片</p>
<p>markdown图片语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">one：![alt 属性文本](图片地址)</span><br><span class="line">two：![alt 属性文本](图片地址 &quot;可选标题&quot;)</span><br></pre></td></tr></table></figure>

<ul>
<li>开头一个感叹号</li>
<li>接着一个方括号，里面房上图片替代文字</li>
<li>接着一个普通括号，里面放上图片网址，最后还可以用引号包住并加上选择性的“title”属性文字。</li>
</ul>
<p>也可以像网址一样对图片使用变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这个链接用1作为网址变量[图片][2]</span><br><span class="line">然后在文档结尾处</span><br><span class="line">[2]:1600008709385.jpg</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>示例；</p>
<p>这个链接用1作为网址变量<a href="1600008709385.jpg">图片</a><br>然后在文档结尾处</p>
<p>markdown没办法指定图片高度，如果需要可以使用普通的<img></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src&#x3D;10898738_143746326185_2.jpg width&#x3D;40%&gt;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<h3 id="11-markdown制作表格使用-来分隔不同的单元格，使用-来表示分隔表头和其他进行。"><a href="#11-markdown制作表格使用-来分隔不同的单元格，使用-来表示分隔表头和其他进行。" class="headerlink" title="11.markdown制作表格使用|来分隔不同的单元格，使用-来表示分隔表头和其他进行。"></a>11.markdown制作表格使用<code>|</code>来分隔不同的单元格，使用<code>-</code>来表示分隔表头和其他进行。</h3><p>语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|表头		|表头		|</span><br><span class="line">|--------|---------|</span><br><span class="line">|单元格   |单元格    |</span><br><span class="line">|单元格   |单元格    |</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<table>
<thead>
<tr>
<th>表头</th>
<th>表头</th>
</tr>
</thead>
<tbody><tr>
<td>单元格</td>
<td>单元格</td>
</tr>
<tr>
<td>单元格</td>
<td>单元格</td>
</tr>
</tbody></table>
<p>对齐方式：</p>
<ul>
<li><code>-:</code>设置内容和标题栏右对齐。</li>
<li><code>:-</code>设置内容和标题栏左对齐。</li>
<li><code>:-:</code>设置内容和标题栏居中对齐。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|左对齐		|居中对齐	|右对齐		|</span><br><span class="line">|:--------------|:-----------:|-----------:|</span><br><span class="line">|单元格   |单元格    |单元格    |</span><br><span class="line">|单元格   |单元格    |单元格    |</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">左对齐</th>
<th align="center">居中对齐</th>
<th align="right">右对齐</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单元格</td>
<td align="center">单元格</td>
<td align="right">单元格</td>
</tr>
<tr>
<td align="left">单元格</td>
<td align="center">单元格</td>
<td align="right">单元格</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown-2</title>
    <url>/markdown-2/</url>
    <content><![CDATA[<hr>
<center><b>markdown—基础二</b></center>

<span id="more"></span>

<h1 id="1-引用"><a href="#1-引用" class="headerlink" title="1.引用"></a>1.引用</h1><p>在markdown中，引用由&gt;+引用内容来标记，如下所示。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 引用内容</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<blockquote>
<p>引用内容</p>
</blockquote>
<p>语法说明如下：</p>
<p>1）多行引用也可以在每行的开头都插入&gt;.</p>
<p>2)在引用中可以嵌套引用。</p>
<p>3）在引用中可以使用其他的markdown语法。</p>
<p>4）段落与换行的格式在引用中也是适用的。</p>
<h1 id="2-转义"><a href="#2-转义" class="headerlink" title="2. 转义"></a>2. 转义</h1><p>当我们想在markdown文件中插入一些标记符号，但又不想让这些符号被渲染时，可以使用\进行转转义，语法如下》</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\特殊符号</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可被转义符号如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\ 反斜线</span><br><span class="line">&#96; 反引号</span><br><span class="line">* 星号</span><br><span class="line">_ 底线</span><br><span class="line">&#123;&#125; 花括号</span><br><span class="line">[] 方括号</span><br><span class="line"># 井字号</span><br><span class="line">+ 加号</span><br><span class="line">- 减号</span><br><span class="line">. 英文句点</span><br><span class="line">！惊叹号</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="3-扩展语法GFM"><a href="#3-扩展语法GFM" class="headerlink" title="3. 扩展语法GFM"></a>3. 扩展语法GFM</h1><p>在众多markdown扩展语法中，GitHub Flavored Markdown （简称GFM）无疑时目前最流行的，它提供了包括表格，任务列表，删除线，围栏代码，Emoji等在内的标记语法，本书介绍的工具基本都支持GFM。</p>
<h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p>删除线语法如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~~被删除的文字~~</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<p><del>被删除的文字</del></p>
<h2 id="表情符号"><a href="#表情符号" class="headerlink" title="表情符号"></a>表情符号</h2><p>使用：包裹表情代码即可，语法如下》</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:smile:（笑脸）</span><br><span class="line">:bowtie:</span><br><span class="line">:smile:</span><br><span class="line">:simple_smile:</span><br><span class="line">:laughing:</span><br><span class="line">:blush:</span><br><span class="line">:smiley:</span><br><span class="line">:relaxed:</span><br><span class="line">:smirk:</span><br><span class="line">:heart_eyes:</span><br><span class="line">:kissing_heart:</span><br><span class="line">:kissing_closed_eyes:</span><br><span class="line">:flushed:</span><br><span class="line">:relieved:</span><br><span class="line">:satisfied:</span><br><span class="line">:grin:</span><br><span class="line">:wink:</span><br><span class="line">:stuck_out_tongue_winking_eye:</span><br><span class="line">:stuck_out_tongue_closed_eyes:</span><br><span class="line">:grinning:</span><br><span class="line">:kissing:</span><br><span class="line">:kissing_smiling_eyes:</span><br><span class="line">:stuck_out_tongue:</span><br><span class="line">:sleeping:</span><br><span class="line">:worried:</span><br><span class="line">:frowning:</span><br><span class="line">:anguished:</span><br><span class="line">:open_mouth:</span><br><span class="line">:grimacing:</span><br><span class="line">:confused:</span><br><span class="line">:hushed:</span><br><span class="line">:expressionless:</span><br><span class="line">:unamused:</span><br><span class="line">:sweat_smile:</span><br><span class="line">:sweat:</span><br><span class="line">:disappointed_relieved:</span><br><span class="line">:weary:</span><br><span class="line">:pensive:</span><br><span class="line">:disappointed:</span><br><span class="line">:confounded:</span><br><span class="line">:fearful:</span><br><span class="line">:cold_sweat:</span><br><span class="line">:persevere:</span><br><span class="line">:cry:</span><br><span class="line">:sob:</span><br><span class="line">:joy:</span><br><span class="line">:astonished:</span><br><span class="line">:scream:</span><br><span class="line">:neckbeard:</span><br><span class="line">:tired_face:</span><br><span class="line">:angry:</span><br><span class="line">:rage:</span><br><span class="line">:triumph:</span><br><span class="line">:sleepy:</span><br><span class="line">:yum:</span><br><span class="line">:mask:</span><br><span class="line">:sunglasses:</span><br><span class="line">:dizzy_face:</span><br><span class="line">:imp:</span><br><span class="line">:smiling_imp:</span><br><span class="line">:neutral_face:</span><br><span class="line">:no_mouth:</span><br><span class="line">:innocent:</span><br><span class="line">:alien:</span><br><span class="line">:yellow_heart:</span><br><span class="line">:blue_heart:</span><br><span class="line">:purple_heart:</span><br><span class="line">:heart:</span><br><span class="line">:green_heart:</span><br><span class="line">:broken_heart:</span><br><span class="line">:heartbeat:</span><br><span class="line">:heartpulse:</span><br><span class="line">:two_hearts:</span><br><span class="line">:revolving_hearts:</span><br><span class="line">:cupid:</span><br><span class="line">:sparkling_heart:</span><br><span class="line">:sparkles:</span><br><span class="line">:star:</span><br><span class="line">:star2:</span><br><span class="line">:dizzy:</span><br><span class="line">:boom:</span><br><span class="line">:collision:</span><br><span class="line">:anger:</span><br><span class="line">:exclamation:</span><br><span class="line">:question:</span><br><span class="line">:grey_exclamation:</span><br><span class="line">:grey_question:</span><br><span class="line">:zzz:</span><br><span class="line">:dash:</span><br><span class="line">:sweat_drops:</span><br><span class="line">:notes:</span><br><span class="line">:musical_note:</span><br><span class="line">:fire:</span><br><span class="line">:hankey:</span><br><span class="line">:poop:</span><br><span class="line">:shit:</span><br><span class="line">:+1:</span><br><span class="line">:thumbsup:</span><br><span class="line">:-1:</span><br><span class="line">:thumbsdown:</span><br><span class="line">:ok_hand:</span><br><span class="line">:punch:</span><br><span class="line">:facepunch:</span><br><span class="line">:fist:</span><br><span class="line">:v:</span><br><span class="line">:wave:</span><br><span class="line">:hand:</span><br><span class="line">:raised_hand:</span><br><span class="line">:open_hands:</span><br><span class="line">:point_up:</span><br><span class="line">:point_down:</span><br><span class="line">:point_left:</span><br><span class="line">:point_right:</span><br><span class="line">:raised_hands:</span><br><span class="line">:pray:</span><br><span class="line">:point_up_2:</span><br><span class="line">:clap:</span><br><span class="line">:muscle:</span><br><span class="line">:metal:</span><br><span class="line">:fu:</span><br><span class="line">:runner:</span><br><span class="line">:running:</span><br><span class="line">:couple:</span><br><span class="line">:family:</span><br><span class="line">:two_men_holding_hands:</span><br><span class="line">:two_women_holding_hands:</span><br><span class="line">:dancer:</span><br><span class="line">:dancers:</span><br><span class="line">:ok_woman:</span><br><span class="line">:no_good:</span><br><span class="line">:information_desk_person:</span><br><span class="line">:raising_hand:</span><br><span class="line">:bride_with_veil:</span><br><span class="line">:person_with_pouting_face:</span><br><span class="line">:person_frowning:</span><br><span class="line">:bow:</span><br><span class="line">:couplekiss:</span><br><span class="line">:couple_with_heart:</span><br><span class="line">:massage:</span><br><span class="line">:haircut:</span><br><span class="line">:nail_care:</span><br><span class="line">:boy:</span><br><span class="line">:girl:</span><br><span class="line">:woman:</span><br><span class="line">:man:</span><br><span class="line">:baby:</span><br><span class="line">:older_woman:</span><br><span class="line">:older_man:</span><br><span class="line">:person_with_blond_hair:</span><br><span class="line">:man_with_gua_pi_mao:</span><br><span class="line">:man_with_turban:</span><br><span class="line">:construction_worker:</span><br><span class="line">:cop:</span><br><span class="line">:angel:</span><br><span class="line">:princess:</span><br><span class="line">:smiley_cat:</span><br><span class="line">:smile_cat:</span><br><span class="line">:heart_eyes_cat:</span><br><span class="line">:kissing_cat:</span><br><span class="line">:smirk_cat:</span><br><span class="line">:scream_cat:</span><br><span class="line">:crying_cat_face:</span><br><span class="line">:joy_cat:</span><br><span class="line">:pouting_cat:</span><br><span class="line">:japanese_ogre:</span><br><span class="line">:japanese_goblin:</span><br><span class="line">:see_no_evil:</span><br><span class="line">:hear_no_evil:</span><br><span class="line">:speak_no_evil:</span><br><span class="line">:guardsman:</span><br><span class="line">:skull:</span><br><span class="line">:feet:</span><br><span class="line">:lips:</span><br><span class="line">:kiss:</span><br><span class="line">:droplet:</span><br><span class="line">:ear:</span><br><span class="line">:eyes:</span><br><span class="line">:nose:</span><br><span class="line">:tongue:</span><br><span class="line">:love_letter:</span><br><span class="line">:bust_in_silhouette:</span><br><span class="line">:busts_in_silhouette:</span><br><span class="line">:speech_balloon:</span><br><span class="line">:thought_balloon:</span><br><span class="line">:feelsgood:</span><br><span class="line">:finnadie:</span><br><span class="line">:goberserk:</span><br><span class="line">:godmode:</span><br><span class="line">:hurtrealbad:</span><br><span class="line">:rage1:</span><br><span class="line">:rage2:</span><br><span class="line">:rage3:</span><br><span class="line">:rage4:</span><br><span class="line">:suspect:</span><br><span class="line">:trollface:</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<p>:smile:（笑脸）</p>
<p>:see_no_evil:</p>
<p>更多表情符号请参考：[表情符号][<a href="http://www.webpagefx.com/tools/emoji-cheat-sheet/]">http://www.webpagefx.com/tools/emoji-cheat-sheet/]</a></p>
<h2 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h2><p>在标准语法中，由&lt;&gt;包裹的URL地址被自动识别并解析为超链接，使用GFM扩展语法则可以不使用&lt;&gt;包裹。语法如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">标准语法中由&lt;&gt;包裹的URL地址被自动识别并解析为超链接。</span><br><span class="line">如:</span><br><span class="line">&lt;www.baidu.com&gt;</span><br><span class="line">使用GFM扩展语法可以不使用&lt;&gt;包裹。如：</span><br><span class="line">www.baidu.com</span><br><span class="line">如果不想自动链接也可以使用&#96;包裹URL地址</span><br><span class="line">&#96;www.baidu.com&#96;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<p>标准语法中由&lt;&gt;包裹的URL地址被自动识别并解析为超链接。<br>如:<br>&lt;<a href="http://www.baidu.com&gt;/">www.baidu.com&gt;</a><br>使用GFM扩展语法可以不使用&lt;&gt;包裹。如：<br><a href="http://www.baidu.com/">www.baidu.com</a></p>
<p>如果不想自动链接也可以使用包裹<code>URL地址</code></p>
<p><code>www.baidu.com</code></p>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>表格语法如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|表头1|表头2|表头3|</span><br><span class="line">|----|----|----|</span><br><span class="line">|内容1|内容2|内容3|</span><br><span class="line">|内容1|内容2|内容3|</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<table>
<thead>
<tr>
<th>表头1</th>
<th>表头2</th>
<th>表头3</th>
</tr>
</thead>
<tbody><tr>
<td>内容1</td>
<td>内容2</td>
<td>内容3</td>
</tr>
<tr>
<td>内容1</td>
<td>内容2</td>
<td>内容3</td>
</tr>
</tbody></table>
<p>语法说明如下：</p>
<p>1）单元格使用|来分隔，为了阅读更清晰，建议最前和最后都使用|。</p>
<p>2）单元格和|之间的空格会被被移除。</p>
<p>3）表头与其他行使用-来分隔。</p>
<p>4）表格对齐格式如下：</p>
<ul>
<li>左对齐（默认）：<code>:</code></li>
<li>右对齐：<code>-:</code></li>
<li>居中对齐：<code>:-:</code></li>
</ul>
<p>5)块级元素（代码区块，引用区块）不能插入表格中。</p>
<h2 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h2><p>任务列表的语法如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- [] 未勾选</span><br><span class="line">- [x] 已勾选</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<ul>
<li><p><input disabled="" type="checkbox">  未勾选</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  已勾选</p>
</li>
</ul>
<p>语法说明如下：</p>
<p>1）任务列表以-+空格开头，由[+空格/x+]组成。</p>
<p>2）x可以是小写，也可以是大写，由些编辑器可能不支持大写，所以为了避免解析错误，推荐使用小写的x。</p>
<h2 id="围栏代码块"><a href="#围栏代码块" class="headerlink" title="围栏代码块"></a>围栏代码块</h2><p>在基础的语法中代码块使用tab键或4格空格开头；在扩展语法中使用连续3个`或3个~~~包裹，还支持语法高亮可读性和可维护性更强一些。</p>
<p>围栏代码块语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1：</span><br><span class="line">​&#96;&#96;&#96;+回车键</span><br><span class="line">或</span><br><span class="line">2：</span><br><span class="line">​&#96;&#96;&#96;（可加代码名称）</span><br><span class="line">代码</span><br><span class="line">​&#96;&#96;&#96;</span><br><span class="line">或</span><br><span class="line">3：</span><br><span class="line">~~~（可加代码名称）</span><br><span class="line">代码</span><br><span class="line">~~~</span><br><span class="line">或</span><br><span class="line">4：</span><br><span class="line">~~~+回车键</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>示例</p>
<p>1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">代码</span><br></pre></td></tr></table></figure>

<p>或<br>3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">代码</span><br></pre></td></tr></table></figure>

<p>或<br>4：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h2><p>锚点，也称为书签，用来标记文档的特定位置，使用锚点可以跳转到当前文档或其他文档中指定的标记位置。</p>
<p>Markdown会被渲染成HTML页面，在HTML页面中可以通过锚点实现跳转；</p>
<p>GitHub、GitBook项目文档中的目录也是通过锚点实现跳转的。</p>
<p>· 锚点的语法如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[锚点描述](#锚点名)</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<p><a href="#1.%E5%BC%95%E7%94%A8">锚点描述</a></p>
<p><a href="#%E5%88%A0%E9%99%A4%E7%BA%BF">锚点描述</a></p>
<p>语法说明如下。</p>
<p>1）锚点名建议使用字母和数字，当然中文也是被支持的，但不排除有些网站支持得不够好。</p>
<p>2）锚点名是区分英文大小写的。</p>
<p>3）在锚点名中不能含由空格，也不能含由特殊字符。</p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title>pandas-1</title>
    <url>/pandas-1/</url>
    <content><![CDATA[<hr>
<h1 id="pandas基础-jupyter"><a href="#pandas基础-jupyter" class="headerlink" title="pandas基础(jupyter)"></a>pandas基础(jupyter)</h1><span id="more"></span>

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=530 height=86 src="//music.163.com/outchain/player?type=2&id=1303019637&auto=0&height=66"></iframe>

<h2 id="一-创建、读取和存储"><a href="#一-创建、读取和存储" class="headerlink" title="一.创建、读取和存储"></a>一.<strong>创建、读取和存储</strong></h2><p>1.创建在 Pandas 中我们想要构造下面这一张表应该如何操作呢？</p>
<table>
<thead>
<tr>
<th></th>
<th>数学</th>
<th>英语</th>
<th>语文</th>
<th>总分</th>
</tr>
</thead>
<tbody><tr>
<td>小明</td>
<td>88</td>
<td>77</td>
<td>86</td>
<td>251</td>
</tr>
<tr>
<td>小刘</td>
<td>86</td>
<td>67</td>
<td>69</td>
<td>222</td>
</tr>
<tr>
<td>小王</td>
<td>96</td>
<td>85</td>
<td>66</td>
<td>247</td>
</tr>
<tr>
<td>小白</td>
<td>77</td>
<td>85</td>
<td>69</td>
<td>231</td>
</tr>
</tbody></table>
<ol>
<li><p>第一步一定是先导入我们的库——import pandas as pd</p>
</li>
<li><p>构造 DataFrame， 最常用的方式是字典+列表，语句很简单，先是字典外括，然后</p>
<p> 依次打出每一列标题及其对应的列值（此处一定要用列表），这里列的顺序并不重要。</p>
<p> 如下所示：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df1=pd.DataFrame(&#123;<span class="string">&#x27;数学&#x27;</span>:[<span class="number">88</span>,<span class="number">86</span>,<span class="number">96</span>,<span class="number">77</span>],<span class="string">&#x27;英语&#x27;</span>:[<span class="number">77</span>,<span class="number">67</span>,<span class="number">85</span>,<span class="number">85</span>],<span class="string">&#x27;语文&#x27;</span>:[<span class="number">86</span>,<span class="number">69</span>,<span class="number">66</span>,<span class="number">69</span>],<span class="string">&#x27;总分&#x27;</span>:[<span class="number">251</span>,<span class="number">222</span>,<span class="number">247</span>,<span class="number">231</span>],index=[<span class="string">&#x27;小明&#x27;</span>，<span class="string">&#x27;小刘&#x27;</span>,<span class="string">&#x27;小王&#x27;</span>,<span class="string">&#x27;小白&#x27;</span>]&#125;)</span><br><span class="line">df1</span><br></pre></td></tr></table></figure>

<p> 实例如下：</p>
 <img src="https://raw.githubusercontent.com/apricot502/images/master/img20210403182153.png" alt="image-20210311211748937" style="zoom: 67%;" /></li>
</ol>
<h2 id="二-读取"><a href="#二-读取" class="headerlink" title="二.读取"></a>二.读取</h2><p>​    更多时候，我们是把相关文件数据直接读进 PANDAS 中进行操作，这里介绍两种非常接近的读取方式，一种是 CSV 格式的文件，一种是 EXCEL 格式（.xlsx 和 xls 后缀）的文件。</p>
<ol>
<li><h3 id="读取-csv-文件："><a href="#读取-csv-文件：" class="headerlink" title="读取 csv 文件："></a>读取 csv 文件：</h3></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df2=pd.read_csv(<span class="string">&#x27;流量练习数据.csv&#x27;</span>,engine=<span class="string">&#x27;python&#x27;</span>)</span><br><span class="line">df2.head()</span><br></pre></td></tr></table></figure>

<p>engine 是使用的分析引擎，读取 csv 文件一般指定 python 避免中文和编码造成的报错。</p>
<p>实例如下：</p>
<img src="https://i.loli.net/2021/03/11/SElF2tompz4hydx.png" alt="image-20210311212801228" style="zoom:67%;" />

<ol start="2">
<li><h3 id="读取-Excel-文件"><a href="#读取-Excel-文件" class="headerlink" title="读取 Excel 文件"></a>读取 Excel 文件</h3></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">df3&#x3D;pd.read_excel(&#39;流量练习数据.xls&#39;)</span><br><span class="line">df3.head()</span><br></pre></td></tr></table></figure>

<p>read_csv 和 read_excel 还有一些参数，比如 header、sep、names 等，大家可以做额外了解。实践中数据源的格式一般都是比较规整的，更多情况是直接读取。</p>
<p>实例：</p>
<img src="https://i.loli.net/2021/03/11/GuvdINsr7lPU8mo.png" alt="image-20210311213353131" style="zoom:67%;" />

<h2 id="三-存储"><a href="#三-存储" class="headerlink" title="三.存储"></a>三.存储</h2><ol>
<li><h3 id="存储excel"><a href="#存储excel" class="headerlink" title="存储excel"></a>存储excel</h3></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df2.to_excel(<span class="string">&#x27;df2.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><h3 id="存储csv"><a href="#存储csv" class="headerlink" title="存储csv"></a>存储csv</h3></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df3.to_csv(<span class="string">&#x27;df3.csv&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/03/11/DymocQawZX8dEiU.png" alt="image-20210311214308041"></p>
<h2 id="四-快速认识数据"><a href="#四-快速认识数据" class="headerlink" title="四.快速认识数据"></a>四.快速认识数据</h2><h3 id="1-查看数据，掐头看尾"><a href="#1-查看数据，掐头看尾" class="headerlink" title="1.查看数据，掐头看尾"></a>1.查看数据，掐头看尾</h3><p>​        很多时候我们想要对数据内容做一个总览，用 df.head()函数直接可以查看默认的前 5 行，与之对应，df.tail()就可以查看数据尾部的 5 行数据，这两个参数内可以传入一个数值来控制查看的行数，例如 df.head(10)表示查看前 10 行数据.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查看前五行</span><br><span class="line">df.head()</span><br><span class="line">#查看后五行</span><br><span class="line">df.tail()</span><br><span class="line">#查看前十行</span><br><span class="line">df.head(10)</span><br></pre></td></tr></table></figure>

<h3 id="2-格式查看"><a href="#2-格式查看" class="headerlink" title="2.格式查看"></a>2.格式查看</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#帮助我们一步摸清各列数据的类型，以及缺失情况</span></span><br><span class="line">df.info()</span><br></pre></td></tr></table></figure>

<img src="https://i.loli.net/2021/03/11/9T1magUSAwEsz3d.png" alt="image-20210311215136221" style="zoom:67%;" />

<p>​        从上面直接可以知道数据集的行列数，数据集的大小，每一列的数据类型，以及有多少条非空数据。</p>
<h3 id="3-统计信息概览"><a href="#3-统计信息概览" class="headerlink" title="3.统计信息概览"></a>3.统计信息概览</h3><p>​    快速计算数值型数据的关键统计指标，像平均数、中位数、标准差等等.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df2.describe()</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<img src="https://i.loli.net/2021/03/11/2aT1sBdzlyZwCrJ.png" alt="image-20210311215511631" style="zoom:67%;" />

<p>​        注意到本来 5 列数据，为什么返回结果只有两列？那是因为这个操作只针对数值型的列。其中 count 是统计每一列的有多少个非空数值，mean、std、min、max对应的分别是该列的均值、标准差、平均值和最大值，25%、50%、75%对应的则是分位数。</p>
<h3 id="4-列的基本处理方式"><a href="#4-列的基本处理方式" class="headerlink" title="4.列的基本处理方式"></a>4.列的基本处理方式</h3><p>​        采用 SQL 四大法宝的逻辑来简单梳理针对列的基本处理方式——增、删、选、改。</p>
<p>​        <code>tip：使用 Pandas 时，尽量避免用行或者 EXCEL 操作单元格的思维来处理数据，要逐渐养成一种列向思维</code></p>
<h4 id="1-增"><a href="#1-增" class="headerlink" title="1.增"></a>1.增</h4><p>​        增加一列，用 df[‘新列名’] = 新列值的形式，在原数据基础上赋值即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df2[&#39;new_line&#39;]&#x3D;range(1,len(df2)+1)</span><br><span class="line">df2.head()</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<img src="https://i.loli.net/2021/03/12/LSoFI89U7Jj3Dey.png" alt="image-20210312111703138" style="zoom:67%;" />



<h4 id="2-删："><a href="#2-删：" class="headerlink" title="2.删："></a>2.删：</h4><p>我们用 drop 函数制定删除对应的列，axis = 1 表示针对列的操作，inplace 为 True，则直接在源数据上进行修改，否则源数据会保持原样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df2.drop(&#39;new_line&#39;,axis&#x3D;1,inplace &#x3D; True)</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/03/12/OvLr2xsXnFuElYm.png" alt="image-20210312111942924"></p>
<h4 id="3-选："><a href="#3-选：" class="headerlink" title="3.选："></a>3.选：</h4><p>想要选取某一列怎么办？df[‘列名’]即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df2[&#39;访客数&#39;]</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/03/12/bYj6tS4UK1wy2vu.png" alt="image-20210312112125161"></p>
<p>选取多列呢？需要用列表来传递：df[[‘第一列’,’第二列’,’第三列’..]]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df2[[&#39;访客数&#39;,&#39;来源明细&#39;]]</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<img src="https://i.loli.net/2021/03/12/aTepoSchMZNrAzm.png" alt="image-20210312112445371"  />

<p><code>tip：加上head()仅查看前五行</code></p>
<h4 id="4-改："><a href="#4-改：" class="headerlink" title="4.改："></a>4.改：</h4><p>​        好事多磨，复杂的针对特定条件和行列的筛选、修改，放在后面结合案例细讲，这里只讲一下最简单的更改：df[‘旧列名’] = 某个值或者某列值，就完成了对原列数值的修改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df2[&#39;访客数&#39;]&#x3D;range(1,len(df2)+1)</span><br><span class="line">df2.head(6)</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<p><img src="https://i.loli.net/2021/03/12/6bkUzHda7XjJOnq.png" alt="image-20210312113515695"></p>
<h2 id="五-常用数据类型及操作"><a href="#五-常用数据类型及操作" class="headerlink" title="五.常用数据类型及操作"></a>五.常用数据类型及操作</h2><h3 id="1-字符串"><a href="#1-字符串" class="headerlink" title="1.字符串"></a>1.字符串</h3><p>​        字符串类型是最常用的格式之一了，Pandas 中字符串的操作和原生字符串操作几乎一毛一样，唯一不同的是需要在操作前加上”.str”。</p>
<p><code>tip:我们最初用 df2.info()查看数据类型时，非数值型的列都返回的是object 格式，和 str 类型深层机制上的区别就不展开了，在常规实际应用中，我们可以先理解为 object 对应的就是 str 格式，int64 对应的就是 int 格式，float64对应的就是 float 格式即可。</code></p>
<p>​        在案例数据中，我们发现来源明细那一列，可能是系统导出的历史遗留问题，每一个字符串前面都有一个“-”符号，又丑又无用，所以把他给拿掉:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df2[&#39;来源明细&#39;].str.replace(&#39;-&#39;,&#39;&#39;)</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<p><img src="https://i.loli.net/2021/03/12/e1ukTP6FH9yMnz4.png" alt="image-20210312114107080"></p>
<p>以上操作并不会改变原数据，再次输入df2.head()：</p>
<p><img src="https://i.loli.net/2021/03/12/xj9rDHeOzXBYt6p.png" alt="image-20210312114229951"></p>
<p>所以，可以替换原数据对应的那一列：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df2[&#39;来源明细&#39;]&#x3D;df2[&#39;来源明细&#39;].str.replace(&#39;-&#39;,&#39;&#39;)</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<p><img src="https://i.loli.net/2021/03/12/myLjcKuPA9zNC6r.png" alt="image-20210312114546648"></p>
<h3 id="2-数值型"><a href="#2-数值型" class="headerlink" title="2.数值型"></a>2.数值型</h3><p>​        数值型数据，常见的操作是计算，分为与单个值的运算，长度相等列的运算。</p>
<p>​        以案例数据为例，源数据访客数我们是知道的，现在想把所有渠道的访客都加上10000，怎么操作呢？</p>
<p>​        只需要选中访客数所在列，然后加上 10000 即可，pandas 自动将 10000 和每一行数值相加，针对单个值的其他运算（减乘除）也是如此。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df2[&#39;访客数&#39;]</span><br><span class="line">df2[&#39;访客数&#39;]+10000</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/03/13/I7isfcJpde4nGuy.png" alt="image-20210313152107623" style="zoom:50%;" /><img src="https://i.loli.net/2021/03/13/ct7b1nsLyNvRXh8.png" alt="image-20210313152127229" style="zoom:50%;" /></p>
<p><code>tip：以上操作并不会改变原数据</code></p>
<p>​            列之间的运算语句也非常简洁。源数据是包含了访客数、转化率和客单价，而实际工作中我们对每个渠道贡献的销售额更感兴趣。（销售额 = 访客数 X 转化率 X 客单价）对应操作语句：df[‘销售额’] = df[‘访客数’] * df[‘转化率’] * df[‘客单价’]但为什么疯狂报错？</p>
<p>​        导致报错的原因，是数值型数据和非数值型数据相互计算导致的。PANDAS 把带“%”符号的转化率识别成字符串类型，我们需要先拿掉百分号，再将这一列转化为浮点型数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df2[&#39;支付转化率&#39;]&#x3D;df2[&#39;支付转化率&#39;].str.replace(&#39;%&#39;,&#39;&#39;).astype(float)</span><br><span class="line">df2.head()</span><br></pre></td></tr></table></figure>

<img src="https://i.loli.net/2021/03/13/CpXvON84dtqM9LV.png" alt="image-20210313152805433" style="zoom: 67%;" />

<p>​        要注意的是，这样操作，把 9.98%变成了 9.98，所以我们还需要让支付转化率除以 100，来还原百分数的真实数值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df2[&#39;支付转化率&#39;]&#x3D;df2[&#39;支付转化率&#39;]&#x2F;100</span><br><span class="line">df2.head()</span><br></pre></td></tr></table></figure>

<img src="https://i.loli.net/2021/03/13/caZHVBKoUjfTFWt.png" alt="image-20210313152955280" style="zoom:67%;" />

<p>然后，再用三个指标相乘计算销售额：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df2[&#39;销售额&#39;]&#x3D;df2[&#39;支付转化率&#39;]*df2[&#39;访客数&#39;]*df2[&#39;客单价&#39;]</span><br><span class="line">df2.head()</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/03/13/wXkSlMKLA5Z4zjO.png" alt="image-20210313153246797"></p>
<h3 id="3-时间类型"><a href="#3-时间类型" class="headerlink" title="3.时间类型"></a>3.时间类型</h3><p>​        PANDAS 中时间序列相关的水非常深，这里只对日常中最基础的时间格式进行讲解，对时间序列感兴趣的同学可以自行查阅相关资料，深入了解。</p>
<p>​        以案例数据为例，我们这些渠道数据，是在 2021 年 3 月 13 日提取的，后面可能涉及到其他日期的渠道数据，所以需要加一列时间予以区分，在 EXCEL 中常用的时间格式是’2021-3-13’或者’2021/3/13’，我们用 PANDAS 来实现一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df2[&#39;date&#39;]&#x3D;&#39;2021-3-13&#39;</span><br><span class="line">df2.head()</span><br></pre></td></tr></table></figure>

<img src="https://i.loli.net/2021/03/13/Gjo5f6hyIEzZlKT.png" alt="image-20210313153918252" style="zoom:67%;" />

<p>在实际业务中，一些时候 PANDAS 会把文件中日期格式的字段读取为字符串格</p>
<p>式，这里我们先把字符串’2019-8-3’赋值给新增的日期列，然后用 to_datetime()</p>
<p>函数将字符串类型转换成时间格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#上半图，dtype:object</span><br><span class="line">df2[&#39;date&#39;]</span><br><span class="line">#下半图dtype:datetime64</span><br><span class="line">df2[&#39;date&#39;]&#x3D;pd.to_datetime(df2[&#39;date&#39;])</span><br><span class="line">df2[&#39;date&#39;].head()</span><br></pre></td></tr></table></figure>

<img src="https://i.loli.net/2021/03/13/GLIw7luzAHb5XRy.png" alt="image-20210313154408801" style="zoom:67%;" />

<p>​        转换成时间格式（这里是 datetime64）之后，我们可以用处理时间的思路高效处理这些数据，比如，我现在想知道提取数据这一天离年末还有多少天（’2021-12-31’），直接做减法（该函数接受时间格式的字符串序列，也接受单个字符串）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pd.to_datetime(&#39;2021-12-31&#39;)-pd.to_datetime(df2[&#39;date&#39;])</span><br></pre></td></tr></table></figure>

<img src="https://i.loli.net/2021/03/13/r3aMBL5vVTGzERH.png" alt="image-20210313154831812" style="zoom:67%;" />]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>pandas-2</title>
    <url>/pandas-2/</url>
    <content><![CDATA[<hr>
<h1 id="玩转Pandas索引（jupyter）"><a href="#玩转Pandas索引（jupyter）" class="headerlink" title="玩转Pandas索引（jupyter）"></a>玩转Pandas索引（jupyter）</h1><span id="more"></span>

<p>​        第一篇潘大师（初识 Pandas）教程考虑到篇幅问题只讲了最基础的列向索引，但这显然不能满足同志们日益增长的个性化服务（选取）需求。为了舒缓痛感，增加快感，满足需求，第二篇内容我们单独把索引拎出来，结合场景详细介绍两种常用的索引方式：</p>
<ul>
<li><p>第一种是基于位置（整数）的索引，案例短平快，有个粗略的了解即可，实际中偶有用到，但它的应用范围不如第二种广泛。</p>
</li>
<li><p>第二种是基于名称（标签）的索引，这是要敲黑板练的重点，因为它将是我们后面进行数据清洗和分析的重要基石。</p>
</li>
</ul>
<p>​    首先，简单介绍一下练习的案例数据：</p>
<img src="https://i.loli.net/2021/03/14/f4TO1M2duLsIlND.png" alt="image-20210314094714042" style="zoom:50%;" />

<p>​        和第一篇数据集一样，记录着不同流量来源下，各渠道来源明细所对应的访客数、支付转化率和客单价。数据集虽然简短（复杂的案例数据集在基础篇完结后会如约而至），但是有足够的代表性，下面开始我们索引的表演。</p>
<h2 id="一。基于位置（数字）的索引"><a href="#一。基于位置（数字）的索引" class="headerlink" title="一。基于位置（数字）的索引"></a>一。基于位置（数字）的索引</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df.iloc[row,col]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一个位置是行索引输入我们要选取的哪几行的位置。</p>
</li>
<li><p>第二个位置是列索引，输入我们想要选取哪几列的位置参数。</p>
</li>
<li><p>索引是从0开始，含首不含尾。</p>
</li>
</ul>
<p>我们需要根据实际情况，填入对应的行参数和列参数：</p>
<h3 id="场景一（行选取）"><a href="#场景一（行选取）" class="headerlink" title="场景一（行选取）"></a>场景一（行选取）</h3><p>目标：选择“流量来源”等于“一级”的所有行。</p>
<p>思路：手指戳屏幕数一数，一级的渠道，是从第 1 行到第 13 行，对应行索引是 0-</p>
<p>12，但 Python 切片默认是含首不含尾的，要想选取 0-12 的索引行，我们得输入</p>
<p>“0:13”，列想要全部选取，则输入冒号“：”即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#df.iloc[:13],这样也可</span><br><span class="line">df.iloc[:13,;]</span><br></pre></td></tr></table></figure>

<p>实例：<img src="https://i.loli.net/2021/03/14/qDsV7ARyPjlINQF.png" alt="image-20210314095256264" style="zoom:67%;" /></p>
<h3 id="场景二（列选取）"><a href="#场景二（列选取）" class="headerlink" title="场景二（列选取）"></a>场景二（列选取）</h3><p>目标：我们想要把所有渠道的流量来源和客单价单拎出来看一看。</p>
<p>思路：所有流量渠道，也就是所有行，在第一个行参数的位置我们输入“：”；再看列，流量来源是第 1 列，客单价是第 5 列，对应的列索引分别是 0 和 4：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df.iloc[;,[0,4]]</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<img src="https://i.loli.net/2021/03/14/5Gp9OkMIx8nTaWm.png" alt="image-20210314095226123" style="zoom:67%;" />

<p>​        值得注意的是，如果我们要跨列选取，得先把位置参数构造成列表形式，这里就是[0,4]，如果是连续选取，则无需构造成列表，直接输入 0:5（选取索引为 0 的列到索引为 4 的列）就好。</p>
<h3 id="场景三（行列交叉选取）"><a href="#场景三（行列交叉选取）" class="headerlink" title="场景三（行列交叉选取）"></a>场景三（行列交叉选取）</h3><p>​        目标：我们想要看一看二级、三级流量来源、来源明细对应的访客和支付转化率</p>
<p>思路：先看行，二级三级渠道对应行索引是 13:17，再次强调索引含首不含尾的原则，我们传入的行参数是 13:18；列的话我们需要流量来源、来源明细、访客和转化，也就是前 4 列，传入参数 0:4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df.iloc[13:18,0:4]</span><br></pre></td></tr></table></figure>

<p>实例：<img src="https://i.loli.net/2021/03/14/2pt5voY4InQGB7m.png" alt="image-20210314095608402" style="zoom:67%;" /></p>
<h2 id="二-基于名称（标签）的索引"><a href="#二-基于名称（标签）的索引" class="headerlink" title="二.基于名称（标签）的索引"></a>二.基于名称（标签）的索引</h2><p>​        为了建立起横向对比的体感，我们依然沿用上面三个场景。</p>
<h3 id="场景一（行选取）："><a href="#场景一（行选取）：" class="headerlink" title="场景一（行选取）："></a>场景一（行选取）：</h3><p>选择一级渠道的所有行。</p>
<p>思路：这次我们不用一个个数位置了，要筛选流量渠道为”一级”的所有行，只需做一个判断，判断流量来源这一列，哪些值等于”一级”。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;流量来源&#x27;</span>]==<span class="string">&#x27;一级&#x27;</span></span><br></pre></td></tr></table></figure>

<p>实例：<img src="https://i.loli.net/2021/03/14/CXcmAn5eEPOBtN9.png" alt="image-20210314095855525" style="zoom:67%;" /></p>
<p>​        返回的结果由 True 和 False（布尔型）构成，在这个例子中分别代表结果等于一级和非一级。在 loc 方法中，我们可以把这一列判断得到的值传入行参数位置，Pandas 会默认返回结果为 True 的行（这里是索引从 0 到 12 的行），而丢掉结果为 False 的行，直接上例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#df.loc[df[&#39;流量来源&#39;]&#x3D;&#x3D;&#39;一级&#39;]，这样也可</span><br><span class="line">df.loc[df[&#39;流量来源&#39;]&#x3D;&#x3D;&#39;一级&#39;,:]</span><br></pre></td></tr></table></figure>

<p>实例：<img src="https://i.loli.net/2021/03/14/q8PDznM3wJH97gX.png" alt="image-20210314100051417" style="zoom:67%;" /></p>
<h3 id="场景二（列选取）："><a href="#场景二（列选取）：" class="headerlink" title="场景二（列选取）："></a>场景二（列选取）：</h3><p>我们想要把所有渠道的流量来源和客单价单拎出来看一看。</p>
<p>思路：所有渠道等于所有行，我们在行参数位置直接输入“:”，要提取流量来源和客单价列，直接输入名称到列参数位置，由于这里涉及到两列，所以得用列表包起来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df.loc[:,[&#39;流量来源&#39;,&#39;客单价&#39;]]</span><br></pre></td></tr></table></figure>

<img src="https://i.loli.net/2021/03/14/kfvx6G2Ii5UZ87b.png" alt="image-20210314100455536" style="zoom:67%;" />

<h3 id="场景三（行列交叉选取）："><a href="#场景三（行列交叉选取）：" class="headerlink" title="场景三（行列交叉选取）："></a>场景三（行列交叉选取）：</h3><p>我们想要提取二级、三级流量来源、来源明细对应的访客和支付转化率。</p>
<p>思路：行提取用判断，列提取输入具体名称参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df.loc[df[&#39;流量来源&#39;].isin([&#39;二级&#39;,&#39;三级&#39;]),[&#39;流量来源&#39;,&#39;来源明细&#39;,&#39;访客数&#39;,&#39;支付转化率&#39;]]</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<p><img src="https://i.loli.net/2021/03/14/Gpls6MCQaef1jBV.png" alt="image-20210314101043051"></p>
<p>​        此处插入了一条 isin 函数，这个函数能够帮助我们快速判断源数据中某一列（Series）的值是否等于列表中的值。拿案例来说，df[‘流量来源’].isin([‘二级’,’三 级’])，判断的是流量来源这一列的值，是否等于“二级”或者“三级”，如果等于（等于任意一个）就返回 True，否则返回 False。我们再把这个布尔型判断结果传入行参数，就能够很容易的得到流量来源等于二级或者三级的渠道。</p>
<p>显然loc 的应用场景更加广泛，应该给他加个鸡腿，再来个接地气的场景练练手。插入场景之前，我们先花 30 秒的时间捋一捋 Pandas 中列（Series）向求值的用法，具体操作如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df[&#39;访客数&#39;].mean()#计算均值</span><br><span class="line">df[&#39;访客数&#39;].std()#计算标准差</span><br><span class="line">df[&#39;访客数&#39;].median()#计算中位数</span><br><span class="line">df[&#39;访客数&#39;].max()#计算最大值</span><br><span class="line">df[&#39;访客数&#39;].min()#计算最小值</span><br></pre></td></tr></table></figure>

<p><strong>场景四：</strong></p>
<p>对于流量渠道数据，我们真正应该关注的是优质渠道，假如这里我们定义访客数、转化率、客单价都高于平均值渠道是优质渠道，那怎么找到这些渠道呢？</p>
<p>思路：优质渠道，得同时满足访客、转化、客单高于平均值这三个条件，这是解题的关键。</p>
<p>先看看均值各是多少：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&#39;访客数均值：&#39;,df[&#39;访客数&#39;].mean())</span><br><span class="line">print(&#39;转化率均值：&#39;,df[&#39;支付转化率&#39;].mean())</span><br><span class="line">print(&#39;客单价均值：&#39;,df[&#39;客单价&#39;].mean())</span><br></pre></td></tr></table></figure>

<p>实例：<img src="https://i.loli.net/2021/03/14/YzUb9EhwKJ4Zmtn.png" alt="image-20210314102139194" style="zoom: 67%;" /></p>
<p>再判断各指标列是否大于均值，要三个条件同时满足，他们之间是一个“且”的关系（同时满足），在 pandas中，要表示同时满足，各条件之间要用”&amp;”符号连接，条件内部最好用括号区分；如果是“或”的关系（满足一个即可），则用“|”符号连接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(df[&#39;访客数&#39;] &gt; df[&#39;访客数&#39;].mean()) &amp; (df[&#39;支付转化率&#39;] &gt; df[&#39;支付转化率&#39;].mean()) &amp; (df[&#39;客单价&#39;] &gt; df[&#39;客单价&#39;].mean())</span><br></pre></td></tr></table></figure>
<p>实例：</p>
<p><img src="https://i.loli.net/2021/03/14/kmItuWGAfzMyp4D.png" alt="image-20210314102321867"></p>
<p>​        这样连接之后，返回 True 则表示该渠道同时满足访客、转化率、客单价都高于均值的条件，接下来我们只需要把这些值传入到行参数的位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df.loc[(df[&#39;访客数&#39;] &gt; df[&#39;访客数&#39;].mean()) &amp; </span><br><span class="line">      (df[&#39;支付转化率&#39;] &gt; df[&#39;支付转化率&#39;].mean()) &amp; </span><br><span class="line">      (df[&#39;客单价&#39;] &gt; df[&#39;客单价&#39;].mean()),:]</span><br></pre></td></tr></table></figure>
<p>实例：</p>
<img src="https://i.loli.net/2021/03/14/lCoxiRYj2zrJXsE.png" alt="image-20210314102514439" style="zoom:67%;" />

<p>​        到这一步，我们直接筛选出了 4 条关键指标都高于均值的优质渠道。这两种索引方式，分别是基于位置（数字）的索引和基于名称（标签）的索引，关键在于把脑海中想要选取的行和列，映射到对应的行参数与列参数中去。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>pandas-3</title>
    <url>/pandas-3/</url>
    <content><![CDATA[<hr>
<h1 id="Pandas常用功能"><a href="#Pandas常用功能" class="headerlink" title="Pandas常用功能"></a>Pandas常用功能</h1><span id="more"></span>

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=420 height=86 src="//music.163.com/outchain/player?type=2&id=1489064589&auto=0&height=66"></iframe>

<p>​        首先，导入案例数据集。因为案例数据存放在同一个 Excel 表的不同 Sheet 下，我们需要指定 sheetname 分别读取：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d1&#x3D;pd.read_excel(&#39;清洗数据集.xlsx&#39;,sheet_name&#x3D;&#39;一级流量&#39;)</span><br><span class="line">d1.head()</span><br><span class="line">d1&#x3D;pd.read_excel(&#39;清洗数据集.xlsx&#39;,sheet_name&#x3D;&#39;二级流量&#39;)</span><br><span class="line">d1.head()</span><br><span class="line">d1&#x3D;pd.read_excel(&#39;清洗数据集.xlsx&#39;,sheet_name&#x3D;&#39;三级流量&#39;)</span><br><span class="line">d1.head()</span><br></pre></td></tr></table></figure>

<p>示例：           <img src="https://i.loli.net/2021/03/19/rGX49wxsqiBtgzj.png" alt="image-20210316111131629" style="zoom: 50%;" /><img src="https://i.loli.net/2021/03/19/5bzPdp1Je6YvxOn.png" alt="image-20210316111243282" style="zoom:50%;" /></p>
<img src="https://i.loli.net/2021/03/19/PKrcXJ4SkhQ6DtU.png" alt="image-20210316111307925" style="zoom: 50%;" />

<p>读取完数据，就可以开始进行列表的操作了。</p>
<h2 id="一，增——拓展数据维度"><a href="#一，增——拓展数据维度" class="headerlink" title="一，增——拓展数据维度"></a>一，增——拓展数据维度</h2><h3 id="1-纵向合并"><a href="#1-纵向合并" class="headerlink" title="1.纵向合并"></a>1.纵向合并</h3><p>​        这三个 sheet 的数据，列维度完全一致（每列数据都是同一类型），纵向合并起来分析十分方便。说到纵向合并，concat 大佬不请自来，他的招式简单明了——pd.concat([表 1，表 2，表 3])，表 1，表 2，表 3分别为三个sheet的名字，对于列字段统一的数据，我们只需把表依次传入参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df &#x3D; pd.concat([d1,d2,d3])</span><br><span class="line">df</span><br></pre></td></tr></table></figure>

<p>示例如下：<img src="https://i.loli.net/2021/03/19/J7D69Vy1R8p3ths.png" alt="image-20210316112211162" style="zoom:50%;" /></p>
<p>注：cancat传入参数axis设置成1，可以进行横向的合并；pandas 中很多函数功能十分强大，能够实现多种功能，但对于萌新来说，过多甚至交叉的功能往往会造成懵 B 的状态，所以这里一种功能先只用一种方式来实现。</p>
<h3 id="2-横向合并"><a href="#2-横向合并" class="headerlink" title="2.横向合并"></a>2.横向合并</h3><p>横向合并涉及到连接问题，为方便理解，我们构造一些更有代表性的数据集练手：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">h1 &#x3D; pd.DataFrame(&#123;&#39;语文&#39;:[93,80,85,76,58],&#39;数学&#39;:[87,99,95,85,70],&#39;英语&#39;:[80,85,97,65,88]&#125;,index &#x3D; [&#39;韩梅梅&#39;,&#39;李雷&#39;,&#39;李华&#39;,&#39;王明&#39;,&#39;铁蛋&#39;])</span><br><span class="line">h1</span><br><span class="line">h2 &#x3D; pd.DataFrame(&#123;&#39;篮球&#39;:[93,80,85,76],&#39;舞蹈&#39;:[87,99,95,85]&#125;,</span><br><span class="line">                 index &#x3D; [&#39;李华&#39;,&#39;王明&#39;,&#39;铁蛋&#39;,&#39;刘强&#39;])</span><br><span class="line">h2</span><br></pre></td></tr></table></figure>
<p>实例：<br><img src="https://i.loli.net/2021/03/19/TEH2uXosYSm3qRM.png" alt="image-20210316115248466" style="zoom: 50%;" /></p>
<img src="https://i.loli.net/2021/03/19/casHZtyGORkEpuz.png" alt="image-20210316115430612" style="zoom:50%;" />

<p>​        两个 DataFrame 是两张成绩表，h1 是 5 位同学的数学、英语、语文成绩，h2 是 4 位同学的篮球和舞蹈成绩，现在想找到并合并两张表同时出现的同学及其成绩，可以用 merge 方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pd.merge(left &#x3D; h1,right &#x3D; h2,left_index &#x3D; True,right_index &#x3D; True,how &#x3D; &#39;inner&#39;)</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<p>![111](<a href="https://raw.githubusercontent.com/apricot502/images/master/img20210403190912.png&quot;">https://raw.githubusercontent.com/apricot502/images/master/img20210403190912.png&quot;</a> alt=”image-20210316115645619” style=”zoom:50%;”)</p>
<p>详解一下 merge 的参数，left 和 rgiht 分别对应着需要连接的左表和右表，这里语数外成绩表是左表，篮球、舞蹈成绩是右表。left_index 与 right_index 是当我们用索引（这两个表的名字在索引中）连接时指定的参数，设置为 on 表示用该表的索引作为连接的条件（或者说桥梁）。假设姓名是单独的一列值，且需要根据姓名进行匹配，那就需要用“left_on = ‘姓名’,right_on = ‘姓名’”，我们可以分别指定左表的匹配列和右表的匹配列。</p>
<p>how 是指定连接方式，这里用的 inner，表示我们基于姓名索引来匹配，只返回两个表中共同（同时出现）姓名的数据。下面详解一下 inner 还涉及到的其他参数——left,right,outer。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pd.merge(left &#x3D; h1,right &#x3D; h2,left_index &#x3D; True,right_index &#x3D; True,how &#x3D; &#39;right&#39;)</span><br><span class="line">pd.merge(left &#x3D; h1,right &#x3D; h2,left_index &#x3D; True,right_index &#x3D; True,how &#x3D; &#39;left&#39;)</span><br><span class="line">pd.merge(left &#x3D; h1,right &#x3D; h2,left_index &#x3D; True,right_index &#x3D; True,how &#x3D; &#39;outer&#39;)</span><br></pre></td></tr></table></figure>

<p><strong>左右连接，outer：</strong></p>
<p>right：<img src="https://i.loli.net/2021/03/18/N3QImDTZj2nFoVi.png" alt="image-20210316120307528" style="zoom:67%;" /></p>
<p>left ：<img src="https://i.loli.net/2021/03/19/aKsqBwyehl9iVrL.png" alt="image-20210316120346659" style="zoom: 67%;" /></p>
<p>outer:<img src="https://i.loli.net/2021/03/19/p6BtHdVG2QP5Z7o.png" alt="image-20210316120438719" style="zoom:67%;" /></p>
<p>左连接（left）和右连接（right），我们可以直观理解为哪边的表是主体，谁是主体（所有行全部保持），先看左连接：左表 h1 原封不动，右边根据左表进行合并，如果存在相关的名字，就正常返回数据，如果不存在（韩梅梅、李雷），就返回空(NAN)值；</p>
<p>右连接：就是以右表为主体，左表有则返回无则为空。</p>
<p>外连接：两张表并集的产物，我的数据全保留，你的也全保留，你有我无的就空着，你无我有的也空着。</p>
<h2 id="二，删——删空去重"><a href="#二，删——删空去重" class="headerlink" title="二，删——删空去重"></a>二，删——删空去重</h2><h3 id="1-删空"><a href="#1-删空" class="headerlink" title="1.删空"></a>1.删空</h3><p>在一些场景，源数据的缺失（空值）对于分析来说是干扰项，需要系统的删除。上文我们合并后的 df 数据集就是有缺失数据的：</p>
<img src="https://i.loli.net/2021/03/19/xu3jRpHXQVeJknv.png" alt="image-20210316121222330" style="zoom:67%;" />

<p>要删除空值，一个 dropna 即可搞定：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df.dropna()</span><br></pre></td></tr></table></figure>

<img src="https://i.loli.net/2021/03/19/BeZc4G7NmDnVpFA.png" alt="image-20210316121330467" style="zoom:50%;" />

<p>dropna 函数默认删除所有出现<strong>空值的行</strong>，即只要一行中任意一个字段为空，就会被删除。我们可以设置 subset 参数，例如 dropna(subset = [‘city’])，来指定当一行中的 city 字段为空时，才会被删除。</p>
<h3 id="2-去重"><a href="#2-去重" class="headerlink" title="2.去重"></a>2.去重</h3><p>说是讲去重，但是案例数据比较干净，没有两行数据是完全一样的，所以我们要制造点困难，增加几行重复值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repeat &#x3D; pd.concat([df,df])</span><br><span class="line">print(&#39;重复的数据集一共多少行：&#39;,len(repeat))</span><br></pre></td></tr></table></figure>

<p>实例：<img src="https://i.loli.net/2021/03/19/wmqAogZufdEBp48.png" alt="image-20210318223435029" style="zoom:67%;" /></p>
<p>把源数据重复两遍，赋值给 repeat，这样每一行数据都有重复的数据。要把重复数据删掉，一行代码就搞定：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unique &#x3D; repeat.drop_duplicates()</span><br><span class="line">print(&#39;去重后的数据集一共多少行：&#39;,len(unique))</span><br><span class="line">unique</span><br></pre></td></tr></table></figure>

<p>实例：<img src="https://i.loli.net/2021/03/19/ASIO8lM7LZ1m3fj.png" alt="image-20210318223544833" style="zoom:67%;" /></p>
<p><strong>drop_duplicates 方法去重默认会删掉完全重复的行</strong>（每个值都一样的行），如果我们要删除指定列重复的数据，可以通过指定 subset 参数来实现，假如我们有个奇葩想法，要基于“流量级别”这列进行去重，则可以：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df.drop_duplicates(subset &#x3D; &#39;流量级别&#39;)</span><br></pre></td></tr></table></figure>

<p>实例：<img src="https://i.loli.net/2021/03/18/DMFtsuVkqYvy6zZ.png" alt="image-20210318224024320"></p>
<p>​        我们会发现，流量有三个级别，通过指定 <strong>subset</strong> 参数，我们删除了这个字段重复的行，保留了各自不重复的第一行。继续展开讲，在源数据中，流量渠道为“一级”的有 7 行数据，每行数据其他字段都不相同，这里我们删除了后 6 行，只保留了第一行，但如果我们想在去重的过程中删除前面 6 行，保留最后一行数据怎么操作？答案很简单，指定 keep 参数即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df.drop_duplicates(subset &#x3D; &#39;流量级别&#39;,keep &#x3D; &#39;last&#39;)</span><br></pre></td></tr></table></figure>

<p>实例：<img src="https://i.loli.net/2021/03/18/7BHWrvIhGVwsk3j.png" alt="image-20210318223827090" style="zoom:67%;" /></p>
<p>keep 值等于 last，保留最后一行数据，不输入 keep 值时，系统默认会给 keep 赋值为 first，就会保留第一行数据而删掉其他的。</p>
<h2 id="三，查——基于条件查询"><a href="#三，查——基于条件查询" class="headerlink" title="三，查——基于条件查询"></a>三，查——基于条件查询</h2><p>​        查，不是单纯的返回几行数据，而是根据业务实际需求，基于一定的条件查看和选择数据。</p>
<h3 id="1-按条件索引-筛选"><a href="#1-按条件索引-筛选" class="headerlink" title="1.按条件索引/筛选"></a>1.按条件索引/筛选</h3><p>这次需求是筛选出访客数大于 10000 的一级渠道，loc 一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df.loc[(df[&#39;访客数&#39;] &gt; 10000) &amp; (df[&#39;流量级别&#39;] &#x3D;&#x3D; &#39;一级&#39;),:]</span><br></pre></td></tr></table></figure>

<p>实例：<img src="https://i.loli.net/2021/03/18/yPKoHC7saBjXlZc.png" alt="image-20210318224752271" style="zoom:67%;" /></p>
<h3 id="2-排序"><a href="#2-排序" class="headerlink" title="2.排序"></a>2.排序</h3><p>​        很多情况下，我们都需要通过排序来观察数据规律，以及快速筛选出 TOP N 的数据项。对于案例数据，我们怎么样按交易金额进行排序并筛选出 TOP3 的渠道呢？</p>
<p>问题的关键就在于排序，这个时候 sort_values 函数就派上用场了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort_df &#x3D; df.sort_values(&#39;支付金额&#39;,ascending &#x3D; False)</span><br><span class="line">sort_df</span><br></pre></td></tr></table></figure>

<p>实例：<img src="https://i.loli.net/2021/03/19/h56YAC1zSVHi4s9.png" alt="image-20210319093118845" style="zoom:67%;" /></p>
<p>​        整个操作十分简单，sort_values 函数，顾名思义是按照<strong>数值</strong>进行排序，首先要传入的参数是列参数，即我们根据哪一列的数值来进行排序，ascending 参数决定了排序顺序，等于 Flase 则是从大到小的降序，设置为 True 则是升序。</p>
<p>排序完之后，筛选 TOP3 渠道就非常简单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort_df.head(3)</span><br></pre></td></tr></table></figure>

<p>实例：<img src="https://i.loli.net/2021/03/19/WETFdzMgmjvYyxD.png" alt="image-20210319093252407" style="zoom:67%;" /></p>
<p>​        补充一个知识点，如果跟着文章操作，会发现无论是删空的 dropna，还是去重的drop_duplicates，或者是排序的 sort_values，在对源数据进行操作后，源数据并未改变，这是因为我们没有对这几个函数的 inplace 值进行设置，如果设置成inplace = True，删空、去重和排序都会在源数据上生效。但这里为了避免出现不必要的错误而无法更改，更建议大家把操作后的源数据赋值给新的变量，如 new = df.dropna()，而不是将源数据的 inplace 参数设置为True。</p>
<h2 id="四，分——分组和切分"><a href="#四，分——分组和切分" class="headerlink" title="四，分——分组和切分"></a>四，分——分组和切分</h2><p>在分组的版块中，我们重点介绍groupby 分组和 cut 切分。</p>
<h3 id="1-分组"><a href="#1-分组" class="headerlink" title="1.分组"></a>1.分组</h3><p>​        在案例数据中，总的流量级别有三级，每一级下又有多个投放地区，如果我们想汇总看每个级别流量所对应的总访客数和支付金额，就需要用到分组了。groupby 是分组函数，最主要的参数是列参数，即按照哪一列或者哪几列（多列要用列表外括）进行汇总，这里是按照流量级别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df.groupby(&#39;流量级别&#39;)</span><br></pre></td></tr></table></figure>

<p>实例：<img src="https://i.loli.net/2021/03/19/QuEB1xeZc2KOl3F.png" alt="image-20210319093637450"></p>
<p>​        可以看到，直接分组之后，没有返回任何我们期望的数据，要进一步得到数据，需要在分组的时候对相关字段进行计算（常用的计算方法包括 sum、max、min、mean、std）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df.groupby(&#39;流量级别&#39;).sum()</span><br></pre></td></tr></table></figure>

<p>实例：<img src="https://i.loli.net/2021/03/19/u2VtXaRUJH6OqTI.png" alt="image-20210319094054375" style="zoom:67%;" /></p>
<p>​        后面加上了 sum，代表我们先按照流量级别进行分组，再对分组内的字段求和。由于没有指定求和的列，所以是对所有数值型字段进行了求和。此处我们只想要各级别流量下的访客数和支付金额，需要指明参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#df.groupby(&#39;流量级别&#39;).sum()[[&#39;访客数&#39;,&#39;支付金额&#39;]]这样也可</span><br><span class="line">df.groupby(&#39;流量级别&#39;)[[&#39;访客数&#39;,&#39;支付金额&#39;]].sum()</span><br></pre></td></tr></table></figure>

<p>实例：<img src="https://i.loli.net/2021/03/19/wPzWiER74ajMSxK.png" alt="image-20210319094512545" style="zoom:67%;" /></p>
<p>​        流量级别作为汇总的依据列，默认转化为索引列，如果我们不希望它变成索引，向groupby 内传入参数 <strong>as_index = False</strong> 即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df.groupby(&#39;流量级别&#39;,as_index &#x3D; False)[[&#39;访客数&#39;,&#39;支付金额&#39;]].sum()</span><br></pre></td></tr></table></figure>

<p>实例：<img src="https://i.loli.net/2021/03/19/wvldCoIRhLNfatD.png" alt="image-20210319095107484" style="zoom:67%;" /></p>
<h3 id="2-切分"><a href="#2-切分" class="headerlink" title="2.切分"></a>2.切分</h3><p>切分（分桶）操作常用于一维数组的分类和打标，cut 函数能够高效的完成任务。它的主要参数和用法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pd.cut(x,bins,right,labels)</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>第一个参数x是我们要传入和切分的一维数组，可以是列表，也可以是DataFrame的一列。</li>
<li>bins表示切分的方式，可以自定义传入列表[a,b,c]，表示按照a-b，b-c的区间来进行切分也可以输入数值（例如5），直接指定分成五组。</li>
<li>right的值可以设置为True或者False，当为为True时，表示分组区间是包含右边不包含左边；当为False代表区间含左不含右。</li>
<li>labels则是打标参数，我们把某列数据切分为3组，每一组我们可以给它设置·一个对应的标签，如[低，中，高]。</li>
</ul>
</blockquote>
<p>​        以案例数据为例，每个渠道都有对应的访客数，我们现在希望对各渠道访客级别进行评估，按照访客数大小，分成辣鸡（流量 100 以内的）、百级、千级和万级的渠道。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pd.cut(x &#x3D; df[&#39;访客数&#39;],bins &#x3D; [0,100,1000,10000,100000])</span><br></pre></td></tr></table></figure>

<p>实例：<img src="https://i.loli.net/2021/03/19/HRNzSbcFKTo6mGh.png" alt="image-20210319100722848" style="zoom:50%;" /></p>
<p>​        因为我们想对流量级别进行百、千、万的归类，所以把分组数值标准传入 bins 参数。从结果可以看到，在不设置 right 的情况下，分组区间是默认左开右闭的，而我们希望的是左闭右开，即百级流量渠道访客数在 0-99 之间，所以需要将 right值设置为 False。</p>
<p>​        下面我们直接对分组后的数据进行打标，访客数在 0-99 设置为“辣鸡”，100-999 设置为百级，千级和万级以此类推，同时将打好标签的数据作为新列给到源数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df[&#39;分类打标&#39;] &#x3D; pd.cut(x &#x3D; df[&#39;访客数&#39;],bins &#x3D; [0,100,1000,10000,100000],</span><br><span class="line">                    right &#x3D; False,labels &#x3D; [&#39;辣鸡&#39;,&#39;百级&#39;,&#39;千级&#39;,&#39;万级&#39;])</span><br><span class="line">df</span><br></pre></td></tr></table></figure>

<p>实例：<img src="https://i.loli.net/2021/03/19/HK9F1VSspeLqMi4.png" alt="image-20210319100518628" style="zoom:67%;" /></p>
<p>​        非常高效，一行半代码就搞定了分组、判断和打标的过程。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>pandas-4</title>
    <url>/pandas-4/</url>
    <content><![CDATA[<hr>
<h1 id="Apply-函数"><a href="#Apply-函数" class="headerlink" title="Apply 函数"></a><strong>Apply 函数</strong></h1><span id="more"></span>

<p>apply 函数主要作用是做聚合运算，以及在分组基础上根据实际情况来自定义一些规则，常见用法和参数如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df.groupby([&#39;列名&#39;]).apply(func,args)</span><br></pre></td></tr></table></figure>

<ol>
<li>参数func是最重要的参数，它接收一个函数，会把分组后的数据根据函数来进行处理</li>
<li>args参数是我们可以给函数参入的参数，这个仅做了解，和其他参数一样比较少</li>
</ol>
<h2 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h2><p><strong>背景：</strong>我们拿到了一份 4 位同学三次模拟考试的成绩，想知道每位同学历次模拟中最好成绩和最差成绩分别是多少。</p>
<p><strong>思路：</strong>最好和最差，分别对应着 max 与 min，我们先按姓名分组，再用 apply 函数返回对应的最大和最小值，最终将结果合并。</p>
<p>先导入源数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">score &#x3D; pd.read_excel(&#39;apply案例数据.xlsx&#39;,sheet_name &#x3D; &#39;成绩表&#39;)</span><br><span class="line">score.head(6)</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<img src="https://raw.githubusercontent.com/apricot502/images/master/img20210403150841.png" alt="image-20210403150839651" style="zoom:50%;" />



<p>看一看每位同学最高成绩：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">max_score &#x3D; score.groupby(&#39;姓名&#39;)[&#39;综合成绩&#39;].apply(max).reset_index()</span><br><span class="line">max_score</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<img src="https://raw.githubusercontent.com/apricot502/images/master/img20210403151152.png" alt="image-20210403151148838" style="zoom:50%;" />

<p>​        我们指定“综合成绩”列，然后把 max 函数直接传入 apply 参数内，返回了对应分组内成绩的最大值。有一些常见函数，如 max、min、len 等函数可以直接传入apply。</p>
<p>​        groupby 分组默认会把分组依据列（姓名）变成索引，这里用 reset_index 方法重置或者说取消姓名索引，将它保留在列的位置，维持 DataFrame 格式，方便后续匹配。</p>
<p>再筛选出最低成绩：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">min_score &#x3D; score.groupby(&#39;姓名&#39;)[&#39;综合成绩&#39;].apply(min).reset_index()</span><br><span class="line">min_score</span><br></pre></td></tr></table></figure>

<p>实例：<img src="https://raw.githubusercontent.com/apricot502/images/master/img20210403151356.png" alt="image-20210403151355702"></p>
<p>两张表按姓名合并：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">score_combine &#x3D; pd.merge(max_score,min_score,left_on &#x3D; &#39;姓名&#39;,right_on &#x3D; &#39;姓名&#39;,how &#x3D; &#39;inner&#39;)</span><br><span class="line">score_combine.columns &#x3D; [&#39;姓名&#39;,&#39;最好成绩&#39;,&#39;最差成绩&#39;]</span><br><span class="line">score_combine</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<p><img src="https://raw.githubusercontent.com/apricot502/images/master/img20210403151500.png" alt="image-20210403151459277"></p>
<p>得到了我们预期的结果，只是列名略丑，可以用.columns 方法来赋值更改。场景一比较死板和严肃，场景二我们换个更接地气的风格。</p>
<h2 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h2><p><strong>背景：</strong>Boss 丢过来一份省市销售表，里面包含省份、城市、最近 1 个月销售额 3个字段，没等你开口问需求，Boss 就开腔了：“小 Z 啊，我最近对 3 这个数字有执念，我想看看每个省份销售排名第 3 的都是哪些城市，以及他们的销售额情况。对了，这个需求要尽快！”</p>
<p><strong>思路：</strong>问题的关键是找到每个省份销售排名第 3 的城市，首先，应该对省份、城市按销售额进行降序排列，然后，找到对应排名第 3 的城市，Emmm，如果是排名第 1 的城市，我们可以通过排序后去重实现，但是这个排名第 3，小 Z 疯狂挠头，想到了apply。</p>
<p>先导入数据源，对数据做个初步了解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">order &#x3D; pd.read_excel(&#39;apply案例数据.xlsx&#39;,sheet_name &#x3D; &#39;省市销售数据&#39;)</span><br><span class="line">order.head()</span><br></pre></td></tr></table></figure>

<p>实例·：<img src="https://raw.githubusercontent.com/apricot502/images/master/img20210403151803.png" alt="image-20210403151800730"></p>
<img src="https://raw.githubusercontent.com/apricot502/images/master/img20210403151840.png" alt="image-20210403151839431" style="zoom:67%;" />

<p>数据源有省份、城市、近 1 月销售额 3 个字段，一共 210 行（销售额）乱序排列，且都没有空值，整体比较规整。</p>
<p>要得到销售排名第 3 的城市，要先进行排序，这里我们用省份、近 1 月销售额两个关键字段进行降序排列，得到我们期待的顺序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">order_rank &#x3D; order.sort_values([&#39;省份&#39;,&#39;近1月销售额&#39;],ascending &#x3D; False)</span><br><span class="line">order_rank</span><br></pre></td></tr></table></figure>

<p>实例：<img src="https://raw.githubusercontent.com/apricot502/images/master/img20210403152207.png" alt="image-20210403152206797"></p>
<p>接着，在 apply 函数登场前，我们先详细剖析一下整个过程：</p>
<img src="https://raw.githubusercontent.com/apricot502/images/master/img20210403152607.png" alt="Screenshot 2021-04-03 152337" style="zoom:67%;" />

<p>第一步分组非常简单，按省份分组即可。而取第 3 名的城市和销售，表明我们需要城市和销售两个字段，所以在分组后指明这两列：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">order_rank.groupby(&#39;省份&#39;)[[&#39;城市&#39;,&#39;近1月销售额&#39;]]</span><br></pre></td></tr></table></figure>

<p>实例：<img src="https://raw.githubusercontent.com/apricot502/images/master/img20210403152739.png" alt="image-20210403152738388"></p>
<p>但是我们可以在脑海中构建一下，截图只展示了部分：</p>
<p><img src="https://raw.githubusercontent.com/apricot502/images/master/img20210403201502.png" alt="未标题-1"></p>
<p>有个问题需要注意，有一些直辖市是和省并列的，而作为城市只有单独的一行，这样的城市我们就默认返回其本身的数据；对于非直辖市省份来说，就需要定位筛选。</p>
<p>拿 x2 来举例，要找到这个数据中排名第三的城市和销售额，应该怎么做呢？答案是直接索引，把他看作是一个 DataFrame 格式的表，要选取第 3 行的所有值，包括城市和销售额，这里用 iloc 索引，很简单的一行代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x.iloc[2,:]</span><br></pre></td></tr></table></figure>

<p>下面把我们针对直辖市的判断和非直辖市的筛选逻辑整合成一个函数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def get_third(x):</span><br><span class="line">    #如果分组长度小于等于1，意味着直辖市</span><br><span class="line">    if len(x) &lt;&#x3D; 1:</span><br><span class="line">        #返回第0行的所有值，即直辖市本身</span><br><span class="line">        return x.iloc[0,:]</span><br><span class="line">    </span><br><span class="line">    #针对非直辖市</span><br><span class="line">    else:</span><br><span class="line">        #直接返回第3行（排名第3，索引是2）所有值（城市，近1月销售额）</span><br><span class="line">        return x.iloc[2,:]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">order_rank.groupby(&#39;省份&#39;)[[&#39;城市&#39;,&#39;近1月销售额&#39;]].apply(get_third)</span><br></pre></td></tr></table></figure>


<p>实例：</p>
<p><img src="https://raw.githubusercontent.com/apricot502/images/master/img20210403201509.png" alt="image-20210403201045237"></p>
<p>​        至此，每个省份，销售额排名第三的城市已经成功筛选出来。回顾整个操作流程，先排序，后分组，最后通过定义函数传入 apply，提取出我们的目标值。分组后数据的抽象形态，以及如何判断和取出我们需要的值，是解决问题的关键和难点。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-1</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1/</url>
    <content><![CDATA[<hr>
<h1 id="一-绪论"><a href="#一-绪论" class="headerlink" title="一,绪论"></a>一,绪论</h1><span id="more"></span>

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=420 height=86 src="//music.163.com/outchain/player?type=2&id=1814769698&auto=0&height=66"></iframe>

<h2 id="1-1什么是数据结构"><a href="#1-1什么是数据结构" class="headerlink" title="1.1什么是数据结构"></a>1.1什么是数据结构</h2><p>​        <strong>数据结构定义(P3)</strong>:   是一门研究非数值计算的程序设计问题中计算机的操作对象以及它们之间的关系和操作等的学科。</p>
<p>​        程序设计的实质（P3-4）对确定的问题选择一种好的结构，加上设计一种好的算法。即：程序=数据结构+算法。</p>
<img src="https://i.loli.net/2021/03/17/GJmIgCqAYrUy4bj.png" alt="image-20210317161108282" style="zoom:50%;" />

<p>​        数据结构是介于数学，计算机硬件和计算机软件三者之间的一门核心课程，它不仅是一般程序设计的基础，也是设计和实现编译程序，操作系统，数据库系统及其他系统程序和大型应用程序的重要基础。</p>
<img src="https://i.loli.net/2021/03/17/ZwDK8GjexcmAEPp.png" alt="image-20210317161205118" style="zoom:50%;" />

<h2 id="1-2基本概念与术语"><a href="#1-2基本概念与术语" class="headerlink" title="1.2基本概念与术语"></a>1.2基本概念与术语</h2><p><strong>数据（data) （P4）</strong>—客观事物的符号表示，所有能输入到计算机中并被计算机程序处理的符号的总称<br><strong>数据元素（data element） （P4）</strong>—数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理。也称节点（node）或记录（record）。有时，一个数据元素可由若干数据项组成。<br><strong>数据项（data item）（P4）</strong>—数据不可分割的最小单位，也称域(field)</p>
<p><strong>数据对象（data object）（P4）</strong> —性质相同的数据元素的集合，是数据的一个子集。如整数数据对象</p>
<p><strong>数据结构（P5）</strong>—相互之间存在一种或多种特定关系的数据元素的集合称为，可表示为一个二元组：</p>
<p><img src="https://i.loli.net/2021/03/17/uKN6UqsXQ4niDS3.png" alt="image-20210317161452821"></p>
<p><strong>数据的存储（物理）结构（P6）</strong>—是数据的逻辑结构在计算机存储器内的表示（或映像）。是逻辑结构在计算机存储器中的实现，它依赖于计算机。</p>
<p><strong>存储结构可分为4大类：</strong>顺序、链式==、<em>索引、散列</em>==</p>
<p><strong>顺序存储结构</strong>——借助元素在存储器中的相对位置来表示数据元素间的逻辑关系。<br><strong>链式存储结构</strong>——借助指示元素存储地址的指针表示数据元素间的逻辑关系。</p>
<p>数据的逻辑结构与存储结构密切相关<br>    算法设计——&gt;逻辑结构<br>    算法实现——&gt;存储结构</p>
<p><strong>数据的运算</strong>—在数据的逻辑结构上定义的操作算法,在数据的存储结构上实现。</p>
<p>最常用的数据运算有 5 种：<strong>插入、删除、修改、查找、排序</strong></p>
<h2 id="1-3抽样数据类型的表示与实现"><a href="#1-3抽样数据类型的表示与实现" class="headerlink" title="1.3抽样数据类型的表示与实现"></a>1.3抽样数据类型的表示与实现</h2><p><strong>数据类型（P7）</strong>—高级语言中指数据的取值范围及其上可进行的操作的总称。它和数据结构密切相关，用于刻画（程序）操作对象的特征。数据类型可分为两类：<br>一类是非结构的原子类型；</p>
<p>另一类是结构类型;</p>
<p>C语言中，提供int,  char, float, double等基本      数据类型，数组、结构体、共用体、枚举      等构造数据类型，还有指针、空(void)类      型等。用户也可用typedef 自己定义数据类型</p>
<p><strong>抽象数据类型（abstract data type）（ P7 ）</strong>—由用户定义，用以表示应用问题的数据模型。它由基本的数据类型构成，并包括一组相关的服务（或称操作）。</p>
<ul>
<li>“抽象”的意义在于强调数据类型的数学特性。</li>
<li>与其在计算机内部如何表示和实现无关。</li>
</ul>
<blockquote>
<p>抽象数据类型与数据类型实质上是一个概念，但其特征是使用与实现分离，实行封装和信息隐蔽（独立于计算机）</p>
</blockquote>
<blockquote>
<p>抽象数据类型定义由一个值域和定义在该值域上的一组操作组成，按值的不同特性，可分为下列3种类型：<strong>原子类型、固定聚合类型、可变聚合类型</strong>。后两种可统称为结构类型。</p>
</blockquote>
<p><img src="https://i.loli.net/2021/03/17/dEvTe6S3QUig5xK.png" alt="image-20210317162806798"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DT抽象数据类型名&#123; </span><br><span class="line">        数据对象：&lt;数据对象的定义&gt;</span><br><span class="line">        数据关系：&lt;数据关系的定义&gt; </span><br><span class="line">        基本操作 ：&lt;基本操作的定义&gt; </span><br><span class="line">    &#125; ADT抽象数据类型名</span><br></pre></td></tr></table></figure>

<p>抽象数据类型可以通过固有的数据类型（如整型、实型、字符型等）来表示和实现。</p>
<blockquote>
<p>tip1 ：它有些类似C语言中的结构（struct)类型，但增加了相关的服务。<br>tip2 ：教材中用类C语言（介于伪码和C语言之间）作为描述工具。其描述语法汇总在教材P10-11上。</p>
</blockquote>
<h2 id="1-4算法（algorithm）（-P13-）"><a href="#1-4算法（algorithm）（-P13-）" class="headerlink" title="1.4算法（algorithm）（ P13 ）"></a>1.4<strong>算法（algorithm）（ P13 ）</strong></h2><ul>
<li>什么是算法？如何评判算法的好坏？</li>
<li>时间复杂度和空间复杂度如何表示？</li>
</ul>
<p>—解决某一特定问题的具体步骤的描述，是指令的有限序列，是一系列输入转换为输出的计算步骤。</p>
<p>算法特性（ P13 ）—<strong>有穷性、确定性、可行性、必有输出</strong></p>
<ul>
<li>有穷性 — 一个算法必须在执行有限步骤之后结束。</li>
<li>确定性 —算法的每一步必须是确切定义的，不能产生二义性。</li>
<li>可行性 —算法中描述的操作是可以通过已经实现的基本运算来实现的。</li>
<li>必有输出—一个算法必须有一个或多个输出。</li>
</ul>
<p><strong>程序设计的实质：好算法＋好结构</strong></p>
<ol>
<li><strong>正确性(correctness)  正确的4个层次（ P14 ）</strong></li>
<li><strong>可读性(readability)</strong></li>
<li><strong>健壮性(robustness)</strong></li>
<li><strong>效率与低存储量</strong></li>
</ol>
<p><strong>算法效率——</strong>用依据该算法编制的程序在计算机上执行所消耗的时间来度量。度量有两种方式：</p>
<blockquote>
<p>1.事后统计——利用计算机内记时功能，不同算法的程序可以用一组或多组相同的统计数据区分<br>       缺点：</p>
<ul>
<li>必须先运行依据算法编制的程序。</li>
<li>所得时间统计量依赖于硬件、软件等环境因素，掩盖算法本身的优劣。</li>
</ul>
</blockquote>
<blockquote>
<p>2.事前分析估计——一个高级语言程序在计算机上运行所消耗的时间取决于：</p>
<ul>
<li>依据的算法选用何种策略</li>
<li>问题的规模</li>
<li>程序语言</li>
<li>编译程序产生机器代码质量</li>
<li>机器执行指令速度</li>
</ul>
</blockquote>
<p>​        同一个算法用不同的语言、不同的编译程序、在不同的计算机上运行，效率均不同，所以使用绝对时间单位衡量算法效率不合适。</p>
<pre><code>     一个算法是由控制结构和原操作构成的，则算法时间取决于两者的综合效果。算法时间的量度通常是选取一种对于所研究的问题来说是基本操作的原操作，以该操作的重复执行次数作为算法的时间量度。
</code></pre>
<p>一般地，算法中基本操作重复执行的次数是问题规模n的某个函数f(n)<br>时间复杂度：随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度。简称时间复杂度。——即基本操作（原操作）重复执行的次数的阶数<br>                               <strong>T(n)=o(f(n))</strong></p>
<p>时间复杂度T(n)按数量级递增顺序为：</p>
<p><img src="https://i.loli.net/2021/03/17/YxKAPk3t1Sn6XTq.png" alt="image-20210317165528646"></p>
<p>​            复杂度低——————————————————————————————-&gt;复杂度高</p>
<blockquote>
<p>tip：O（）为渐近符号。</p>
</blockquote>
<p>渐进符号（O）的定义：当且仅当存在一个正的常数 C，使得对所有的 n &gt;= n0 ，有 f(n)&lt;= Cg(n)，则：     f(n) = O(g(n))</p>
<p>例：分析以下程序段的时间复杂度。</p>
<p>i=1;                        ①<br>       while(i&lt;=n)<br>　　        i=i*2;              ②</p>
<p>==解：==</p>
<blockquote>
<p>该算法的运行时间由程序中所有语句的频度（即该语句重复执行的次数）之和构成。</p>
<p><strong>算法的时间复杂度由嵌套最深层语句的频度决定</strong></p>
<p>分析：显然，语句①的频度是1。设语句2的频度是f(n)，则有：<img src="https://i.loli.net/2021/03/17/IvFhYi8CK1ANfRT.png" alt="image-20210317170737068" style="zoom:50%;" /></p>
<p>即f(n)≤log2n，取最大值f(n)=log2n</p>
<p>所以该程序段的时间复杂度T(n)=1+f(n)=1+ log2n= O(log2n)</p>
</blockquote>
<p><strong>空间复杂度：</strong>算法所需存储空间的量度<br>   S(n)=o(f(n))</p>
]]></content>
      <categories>
        <category>course</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-2</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/</url>
    <content><![CDATA[<hr>
<h1 id="二-线性表"><a href="#二-线性表" class="headerlink" title="二 线性表"></a>二 线性表</h1><span id="more"></span>

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=420 height=86 src="//music.163.com/outchain/player?type=2&id=1463165983&auto=0&height=66"></iframe>

<h2 id="2-1线性表的类型定义"><a href="#2-1线性表的类型定义" class="headerlink" title="2.1线性表的类型定义"></a>2.1线性表的类型定义</h2><p>​        线性结构是一个数据元素的有序（次序）集。</p>
<p>​        线性结构的基本特征为：在数据元素的非空有限集合中。</p>
<ol>
<li>必存在唯一的一个“第一元素”；</li>
<li>必存在唯一的一个“最后元素” ；</li>
<li>除最后元素在外，均有唯一的后继；</li>
<li>除第一元素之外，均有唯一的前驱。</li>
</ol>
<blockquote>
<p>线性表是一种最简单的线性结构。</p>
</blockquote>
<p><strong>线性表（P18）</strong>—— 一个线性表是n个数据元素的有限序列。</p>
<p>例：</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>年龄</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>18</td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>19</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
<td>……</td>
</tr>
</tbody></table>
<p><img src="https://i.loli.net/2021/03/17/osm7O15CjZzTJrH.png" alt="image-20210317185933837"></p>
<p><strong>特征：（P19）</strong></p>
<ul>
<li>元素个数n—表长度，n=0空表</li>
<li><blockquote>
<p>1&lt;i&lt;n时</p>
<ul>
<li>ai的直接前驱是ai-1，a1无直接前驱</li>
<li>ai的直接后继是ai+1，an无直接后继</li>
</ul>
</blockquote>
</li>
<li>i为数据元素ai在线性表中的位序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ADT List &#123;</span><br><span class="line">数据对象：</span><br><span class="line">D＝&#123; ai | ai ∈ElemSet, i&#x3D;1,2,...,n,  n≥0 &#125;</span><br><span class="line">&#123;称 n 为线性表的表长; 称 n&#x3D;0 时的线性表为空表。&#125;</span><br><span class="line">数据关系：</span><br><span class="line">R1＝&#123; &lt;ai-1 ,ai &gt;|ai-1 ,ai∈D,  i&#x3D;2,...,n &#125;</span><br><span class="line">&#123;设线性表为 (a1，a2,  . . . ，ai，. . . ，an), 称 i 为 ai 在线性表中的位序。&#125;</span><br><span class="line">基本操作：</span><br><span class="line">结构初始化操作</span><br><span class="line">结构销毁操作</span><br><span class="line">引用型操作</span><br><span class="line">加工型操作</span><br><span class="line">&#125; ADT List</span><br></pre></td></tr></table></figure>

<p>线性表上的基本操作有：<br>⑴  创建线性表：InitList(L)<br>⑵  求线性表的长度：ListLength (L)<br>(3)  按值查找：LocateElem (L,x)，ｘ是给定的一个数据元素。(4)  插入操作：ListInsert(L,i,x)<br>(5)  删除操作：ListDelete (L,i)<br>(6)  显示操作：ListShow (L)     </p>
<p>​        利用上述定义的线性表以实现其它更复杂的操作</p>
<p>例 2-1：</p>
<p>假设:有两个集合A和B分别用两个线性表 LA 和 LB 表示，即：线性表中的数据元素即为集合中的成员。现要求一个新的集合A＝A∪B。</p>
<p>​        即要求对线性表作如下操作：扩大线性表 LA，将存在于线性表LB 中而不存在于线性表 LA 中的数据元素插入到线性表 LA 中去。</p>
<p>1．从线性表LB中依次察看每个数据元素;<code>GetElem(LB, i)→e</code></p>
<p>2．依值在线性表LA中进行查访; <code>LocateElem(LA, e, equal( ))</code></p>
<p>3．若不存在，则插入之。<code> ListInsert(LA, n+1, e)</code> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(List &amp;La, List Lb)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    La_len = ListLength(La);    <span class="comment">// 求线性表的长度</span></span><br><span class="line">    Lb_len = ListLength(Lb);   </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>;  i &lt;= Lb_len;  i++) </span><br><span class="line">    &#123;</span><br><span class="line">    	GetElem(Lb, i, e); <span class="comment">// 取Lb中第i个数据元素赋给e</span></span><br><span class="line">    	<span class="keyword">if</span> (!LocateElem(La, e, equal( )) ) </span><br><span class="line">       			ListInsert(La, ++La_len, e);</span><br><span class="line">      <span class="comment">// La中不存在和 e 相同的数据元素，则插入之</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// union</span></span><br></pre></td></tr></table></figure>



<h2 id="2-2线性表的顺序表示和实现"><a href="#2-2线性表的顺序表示和实现" class="headerlink" title="2.2线性表的顺序表示和实现"></a>2.2线性表的顺序表示和实现</h2><p><strong>线性表的顺序表示（P21）</strong>——用一组地址连续的存储单元存放一个线性表。</p>
<p><img src="https://i.loli.net/2021/03/17/AKfEuahm1XGrCiN.png" alt="image-20210317191313905"></p>
<p><strong>线性表的起始地址称作线性表的基地址</strong></p>
<p>以“存储位置相邻”表示有序对&lt;ai-1，ai&gt;  即：<br>         LOC(ai) = LOC(ai-1) + C 一个数据元素所占存储量↑</p>
<p>所有数据元素的存储位置均取决于第一个数据元素的存储位置<br>             LOC(ai) = LOC(a1) + (i-1)×C<br>                                     ↑基地址</p>
<p>线性表的这种机内表示称做线性表的顺序存储结构或顺序映像（sequential  mapping），这种结构是一种随机存取的存储结构。通常称这种存储结构的线性表为顺序表。</p>
<p>顺序映像—— 以x的存储位置和y的存储位置之间某种关系表示逻辑关系&lt;x,y&gt;。最简单的方法就是令y的存储位置与x的存储位置相邻。</p>
<img src="https://i.loli.net/2021/03/17/6VFaW8RthyOQHTP.png" alt="image-20210317191503215" style="zoom:50%;" />

<pre><code>     高级程序设计语言中的数组类型也有随机存取的特性。因此，通常都用数组来描述顺序存储结构。由于线性表的长度可变，且所需的最大空间随问题不同而不同，则可用动态分配的一维数组实现顺序表。以下为顺序映像的C语言描述。
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define  LIST_INIT_SIZE     100  </span><br><span class="line">          &#x2F;&#x2F; 线性表存储空间的初始分配量</span><br><span class="line">#define  LISTINCREMENT    10 </span><br><span class="line">                    &#x2F;&#x2F; 线性表存储空间的分配增量</span><br><span class="line">typedef  struct </span><br><span class="line">&#123;</span><br><span class="line">  ElemType *elem;    &#x2F;&#x2F; 存储空间基址</span><br><span class="line">  int      length;   &#x2F;&#x2F; 当前长度</span><br><span class="line">  int    listsize;  &#x2F;&#x2F; 当前分配的存储容量  (以sizeof(ElemType)为单位)</span><br><span class="line">&#125; SqList;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="初始化-InitList-Sq"><a href="#初始化-InitList-Sq" class="headerlink" title="初始化 InitList_Sq"></a><strong>初始化 InitList_Sq</strong></h3><p>   算法分析：为顺序表分配一个预定义大小的数组空间，并将线性表的当前长度设置为0.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Status InitList_Sq( SqList   &amp; L ) &#x2F;&#x2F; 构造一个空的线性表                            </span><br><span class="line">&#123;</span><br><span class="line">	L.elem &#x3D; (ElemType*) malloc (LIST_INIT_SIZE*sizeof (ElemType));</span><br><span class="line">	if (!L.elem) exit(OVERFLOW);</span><br><span class="line">	L.length &#x3D; 0;</span><br><span class="line">	L.listsize &#x3D; LIST_INIT_SIZE</span><br><span class="line">	return OK;</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F; InitList_Sq</span><br></pre></td></tr></table></figure>

<h3 id="插入ListInsert"><a href="#插入ListInsert" class="headerlink" title="插入ListInsert"></a><strong>插入ListInsert</strong></h3><blockquote>
<p>算法分析:插入元素时，线性表的逻辑结构发生什么变化？</p>
</blockquote>
<p> (a1, …, ai-1, ai, …, an) 改变为 (a1, …, ai-1, e, ai, …, an)</p>
<img src="https://i.loli.net/2021/03/17/pLOIzWqZjHJeQiY.png" alt="image-20210317192406933" style="zoom:50%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Status ListInsert_Sq(SqList &amp;L, int i, ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F; 在顺序表L的第 i 个元素之前插入新的元素e,</span><br><span class="line"> &#x2F;&#x2F; i 的合法范围为  1≤i≤L.length+1</span><br><span class="line">   if (i &lt; 1 || i &gt; L.length+1) return ERROR;  &#x2F;&#x2F; 插入位置不合法</span><br><span class="line">   if (L.length &gt;&#x3D; L.listsize)</span><br><span class="line">   &#123;&#x2F;&#x2F; 当前存储空间已满，增加分配</span><br><span class="line">   	newbase &#x3D; (ElemType *)realloc(L.elem, (L.listsize+LISTINCREMENT)*sizeof(ElemType));</span><br><span class="line">          if (!newbase) exit(OVERFLOW);      &#x2F;&#x2F; 存储分配失败</span><br><span class="line">          L.elem &#x3D; newbase;                &#x2F;&#x2F; 新基址</span><br><span class="line">          L.listsize +&#x3D; LISTINCREMENT; &#x2F;&#x2F; 增加存储容量&#125;</span><br><span class="line">          q &#x3D; &amp;(L.elem[i-1]);                 &#x2F;&#x2F; q 指示插入位置</span><br><span class="line">          for (p &#x3D; &amp;(L.elem[L.length-1]); p &gt;&#x3D; q;  --p)  </span><br><span class="line">                     *(p+1) &#x3D; *p;       &#x2F;&#x2F; 插入位置及之后的元素右移</span><br><span class="line">           *q &#x3D; e;       &#x2F;&#x2F; 插入e</span><br><span class="line">           ++L.length;   &#x2F;&#x2F; 表长增1</span><br><span class="line">           return OK;&#125; &#x2F;&#x2F; ListInsert_Sq                         </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>算法时间复杂度T(n)<br>设Pi是在第i个元素之前插入一个元素的概率，则在长度为n的线性表中插入一个元素时，所需移动的元素次数的平均次数为：</p>
<p><img src="https://i.loli.net/2021/03/17/ma5yPtGxNn8eDBS.png" alt="image-20210317193200787"></p>
<p>若假定在线性表中任何一个位置上进行插入的概率都是相等的，则移动元素的期望值为：</p>
<p><img src="https://i.loli.net/2021/03/17/5RrfM4lU1wZhB6u.png" alt="image-20210317193234655"></p>
</blockquote>
<h3 id="删除-ListDelet"><a href="#删除-ListDelet" class="headerlink" title="删除 ListDelet"></a>删除 ListDelet</h3><blockquote>
<p>算法分析：删除元素时，线性表的逻辑结构发生什么变化？</p>
</blockquote>
<p> (a1, …, ai-1, ai, ai+1, …, an) 改变为 (a1, …, ai-1, ai+1, …, an)</p>
<img src="https://i.loli.net/2021/03/17/Ad1WLx3bQ2wvUDn.png" alt="image-20210317193506241" style="zoom:50%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Status ListDelete_Sq(SqList &amp;L, int i, ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">       if (i &lt; 1 || i &gt; L.length) return ERROR;  &#x2F;&#x2F; 删除位置不合法</span><br><span class="line">       p &#x3D; &amp;(L.elem[i-1]);      &#x2F;&#x2F; p 为被删除元素的位置</span><br><span class="line">       e &#x3D; *p;                             &#x2F;&#x2F; 被删除元素的值赋给 e</span><br><span class="line">       q &#x3D; L.elem+L.length-1;     &#x2F;&#x2F; 表尾元素的位置</span><br><span class="line">      for (++p; p &lt;&#x3D; q; ++p)  *(p-1) &#x3D; *p;  &#x2F;&#x2F; 被删除元素之后的元素左移</span><br><span class="line">      --L.length;                                             &#x2F;&#x2F; 表长减1    </span><br><span class="line">      return OK;</span><br><span class="line">     &#125; &#x2F;&#x2F; ListDelete_Sq                         </span><br></pre></td></tr></table></figure>

<blockquote>
<p>算法时间复杂度T(n)<br>          假设删除第 i 个元素的概率为     , 则在长度为n 的线性表中删除一个元素所需移动元素次数的期望值为：</p>
<p><img src="https://i.loli.net/2021/03/17/5UcN3IBHl4huO2a.png" alt="image-20210317193730013"></p>
<p>若假定在线性表中任何一个位置上进行删除的概率都是相等的，则移动元素的期望值为：</p>
<p><img src="https://i.loli.net/2021/03/17/SjK2WZE9M7vOR46.png" alt="image-20210317193755526"></p>
</blockquote>
<ul>
<li><blockquote>
<p>顺序表的优缺点？</p>
<p>优点：顺序存储结构的线性表是可以随机存取其中的任意元素。<br>缺点：<br>（1）数据元素最大个数需预先确定，<br>（2）插入与删除运算的效率很低。<br>（3）存储空间不便于扩充。</p>
</blockquote>
</li>
</ul>
<h2 id="2-3线性表的链式表示和实现"><a href="#2-3线性表的链式表示和实现" class="headerlink" title="2.3线性表的链式表示和实现"></a>2.3线性表的链式表示和实现</h2><h2 id="2-4一元多项式的表示和相加"><a href="#2-4一元多项式的表示和相加" class="headerlink" title="2.4一元多项式的表示和相加"></a>2.4一元多项式的表示和相加</h2>]]></content>
      <categories>
        <category>course</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<hr>
<span id="more"></span>]]></content>
  </entry>
  <entry>
    <title>数据结构实验-1</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C-1/</url>
    <content><![CDATA[<hr>
<h1 id="数据结构实验-1"><a href="#数据结构实验-1" class="headerlink" title="数据结构实验-1"></a>数据结构实验-1</h1><span id="more"></span>

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=420 height=86 src="//music.163.com/outchain/player?type=2&id=1426649237&auto=0&height=66"></iframe>

<p>基于visual Studio2017。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 30</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> a[MAXSIZE][<span class="number">12</span>];<span class="comment">//电话号码</span></span><br><span class="line">	<span class="keyword">char</span> name[MAXSIZE][<span class="number">7</span>];<span class="comment">//姓名</span></span><br><span class="line">	<span class="keyword">int</span> length;<span class="comment">//线性表长度</span></span><br><span class="line">&#125;SqList;</span><br><span class="line">SqList a;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*函数申明*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_list</span><span class="params">(SqList* L)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out_list</span><span class="params">(SqList L)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sq</span><span class="params">(SqList* L, <span class="keyword">int</span> I, <span class="keyword">char</span> e[], <span class="keyword">char</span> n[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_sq</span><span class="params">(SqList* L, <span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">locate_sq</span><span class="params">(SqList L, <span class="keyword">char</span> n[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeExcel</span><span class="params">(SqList L, <span class="keyword">char</span> path[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open_list</span><span class="params">(SqList* L, <span class="keyword">int</span> i, <span class="keyword">char</span> path[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hangshu</span><span class="params">(<span class="keyword">char</span> file[])</span></span>;</span><br><span class="line"><span class="comment">/*主函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, k, loc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> ch, n[<span class="number">7</span>], path[<span class="number">50</span>], e[<span class="number">12</span>];</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n=====================================&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n\n\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n        1.新建线性表&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n        2.读取线性表（excel表格）&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n        3.插入元素&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n        4.删除元素&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n        5.查找元素&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n        6.显示线性表所有内容&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n        7.将线性表保存至excel&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n        0.结束程序运行&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n=====================================&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n        请输入您的选择（1,2,3,4,5,6,7,0)：&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">		<span class="keyword">switch</span> (k)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">			create_list(&amp;a);</span><br><span class="line">			out_list(a);</span><br><span class="line">		&#125; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;请输入表格路径（绝对路径或相对路径xxx.xls）：&quot;</span>);</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, path);</span><br><span class="line">			i = hangshu(path);</span><br><span class="line">			open_list(&amp;a, i, path);</span><br><span class="line">		&#125; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n请输入您要插入的位置1-%d:&quot;</span>, a.length+<span class="number">1</span>);</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;i);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;请输入姓名：&quot;</span>);</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;n);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n请输入电话号码：&quot;</span>);</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;e);</span><br><span class="line">			insert_sq(&amp;a, i, e, n);</span><br><span class="line">		&#125; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>: &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n请输入您要删除的位置1-%d:&quot;</span>, a.length);</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;i);</span><br><span class="line">			delete_sq(&amp;a, i);</span><br><span class="line">			out_list(a);</span><br><span class="line">		&#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="number">5</span>: &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n请输入您要查找的数：&quot;</span>);</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, n);</span><br><span class="line">			i = locate_sq(a, n);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;查找的同学在第%d行\n姓名：%s\n电话：%s&quot;</span>, i+<span class="number">1</span>, n, a.a[i]);</span><br><span class="line">		&#125; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">6</span>: &#123;</span><br><span class="line">			out_list(a);</span><br><span class="line">		&#125;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">7</span>: &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;请输入路径(绝对路径或相对路径xxx.xls）：&quot;</span>);</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, path);</span><br><span class="line">			writeExcel(a, path);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;保存成功&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n        0.结束程序运行&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:<span class="built_in">printf</span>(<span class="string">&quot;请重新输入&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (k != <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n       按回车键，返回…\n&quot;</span>);</span><br><span class="line">	ch = getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_list</span><span class="params">(SqList* L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入线性表的长度:&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;L-&gt;length);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; L-&gt;length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;第%d位同学姓名：&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;(L-&gt;name[i]));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;第%d位同学电话：&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;(L-&gt;a[i]));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open_list</span><span class="params">(SqList* L, <span class="keyword">int</span> k, <span class="keyword">char</span> path[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">	fp = fopen(path, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	L-&gt;length = k;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; L-&gt;length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fscanf</span>(fp, <span class="string">&quot;%s\t%s\n&quot;</span>, &amp;L-&gt;name[i], &amp;L-&gt;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out_list</span><span class="params">(SqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; L.length; i++) <span class="built_in">printf</span>(<span class="string">&quot;%7s:%15s\n&quot;</span>, L.name[i], L.a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sq</span><span class="params">(SqList* L, <span class="keyword">int</span> i, <span class="keyword">char</span> e[], <span class="keyword">char</span> n[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">if</span> (L-&gt;length == MAXSIZE) <span class="built_in">printf</span>(<span class="string">&quot;线性表已满&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L-&gt;length + <span class="number">1</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;输入位置错\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = L-&gt;length - <span class="number">1</span>; j &gt;= i - <span class="number">1</span>; j--)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="keyword">sizeof</span>(L-&gt;name[j + <span class="number">1</span>]); k++)</span><br><span class="line">			&#123;</span><br><span class="line">				L-&gt;name[j + <span class="number">1</span>][k] = L-&gt;name[j][k];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="keyword">sizeof</span>(L-&gt;a[j + <span class="number">1</span>]); k++)</span><br><span class="line">			&#123;</span><br><span class="line">				L-&gt;a[j + <span class="number">1</span>][k] = L-&gt;a[j][k];</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="keyword">sizeof</span>(L-&gt;name[i - <span class="number">1</span>]); k++)</span><br><span class="line">		&#123;</span><br><span class="line">			</span><br><span class="line">			L-&gt;name[i - <span class="number">1</span>][k] = n[k];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="keyword">sizeof</span>(L-&gt;a[i - <span class="number">1</span>]); k++)</span><br><span class="line">		&#123;</span><br><span class="line">			L-&gt;a[i - <span class="number">1</span>][k] = e[k];</span><br><span class="line">		&#125;</span><br><span class="line">		L-&gt;length++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_sq</span><span class="params">(SqList* L, <span class="keyword">int</span> i)</span><span class="comment">//删除线性表中的元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> x[<span class="number">12</span>]; <span class="keyword">int</span> j; <span class="keyword">char</span> n[<span class="number">7</span>];</span><br><span class="line">	<span class="keyword">if</span> (L-&gt;length == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;空表! \n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L-&gt;length) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;输入位置错误! \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="keyword">sizeof</span>(L-&gt;name[i - <span class="number">1</span>]); k++)</span><br><span class="line">		&#123;</span><br><span class="line">			x[k] = L-&gt;a[i - <span class="number">1</span>][k];</span><br><span class="line">			n[k] = L-&gt;name[i - <span class="number">1</span>][k];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (j = i; j &lt;= L-&gt;length - <span class="number">1</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="keyword">sizeof</span>(L-&gt;name[i - <span class="number">1</span>]); k++)</span><br><span class="line">			&#123;</span><br><span class="line">				L-&gt;a[j - <span class="number">1</span>][k] = L-&gt;a[j][k];</span><br><span class="line">				L-&gt;name[j - <span class="number">1</span>][k] = L-&gt;name[j][k];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		L-&gt;length--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;删除了：姓名：%s\n电话号码：%12s\n&quot;</span>, n, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">locate_sq</span><span class="params">(SqList L, <span class="keyword">char</span> n[])</span><span class="comment">//查找数据位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= L.length - <span class="number">1</span> &amp;&amp; <span class="built_in">strcmp</span>(L.name[i], n)) i++;</span><br><span class="line">	<span class="keyword">if</span> (i &lt;= L.length - <span class="number">1</span>) <span class="keyword">return</span> (i);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeExcel</span><span class="params">(SqList L, <span class="keyword">char</span> path[])</span><span class="comment">//写入到excel</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">	fp = fopen(path, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(fp, <span class="string">&quot;%s\t%s\n&quot;</span>, L.name[i], L.a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	fclose(fp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hangshu</span><span class="params">(<span class="keyword">char</span> file[])</span><span class="comment">//查看文件有多少行有</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> c[<span class="number">30</span>][<span class="number">30</span>], t[<span class="number">30</span>][<span class="number">30</span>];</span><br><span class="line">	<span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">	FILE *fp;</span><br><span class="line">	fp = fopen(file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//表示文件打开错误</span></span><br><span class="line">	<span class="keyword">while</span> (!feof(fp))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fscanf</span>(fp, <span class="string">&quot;%s\t%s\n&quot;</span>, &amp;c[h], &amp;t[h]);</span><br><span class="line">		<span class="comment">//printf(&quot;%s\t%s\n&quot;, c[h], t[h]);</span></span><br><span class="line"></span><br><span class="line">		h++;</span><br><span class="line">	&#125;</span><br><span class="line">	fclose(fp);</span><br><span class="line">	<span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>course</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表</title>
    <url>/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<hr>
<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><span id="more"></span>

<p>顺序线性表实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct&#x2F;&#x2F;定义线性表结构题</span><br><span class="line">&#123;</span><br><span class="line">char name[20];</span><br><span class="line">char no[10];</span><br><span class="line">float score;</span><br><span class="line">&#125;STUDENT;</span><br><span class="line">STUDENT stu[20];&#x2F;&#x2F;实例化</span><br></pre></td></tr></table></figure>

<h2 id="顺序表的基本操作"><a href="#顺序表的基本操作" class="headerlink" title="顺序表的基本操作"></a>顺序表的基本操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define int datatype;&#x2F;&#x2F;定义元素类型，这里设置为int</span><br><span class="line">#define maxsize 1024</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">datatype elem[maxsize];</span><br><span class="line">int length;&#x2F;&#x2F;表长</span><br><span class="line">&#125;sequenlist；</span><br></pre></td></tr></table></figure>

<p>其中，elem是存放线性表结点的一个数组。</p>
<h3 id="1-顺序表的初始化"><a href="#1-顺序表的初始化" class="headerlink" title="1.顺序表的初始化"></a>1.顺序表的初始化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void  InitList(sequenlist *L)</span><br><span class="line">&#123;</span><br><span class="line">L-&gt;length&#x3D;0;&#x2F;&#x2F;空表，长度为零</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-清除线性表的内容"><a href="#2-清除线性表的内容" class="headerlink" title="2.清除线性表的内容"></a>2.清除线性表的内容</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void clearList(sequenlist *L)</span><br><span class="line">&#123;</span><br><span class="line">L-&gt;length&#x3D;0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-定位查找"><a href="#3-定位查找" class="headerlink" title="3.定位查找"></a>3.定位查找</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int Loc(seqenlist L,datatype Item)</span><br><span class="line">&#123;</span><br><span class="line">int i,j;</span><br><span class="line">j&#x3D;L.length;&#x2F;&#x2F;取出线性表长度</span><br><span class="line">if(j&#x3D;&#x3D;0)&#x2F;&#x2F;空表</span><br><span class="line">return FALSE;</span><br><span class="line">for(i&#x3D;0;i&lt;j;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(L.elem[i]&#x3D;&#x3D;Item)</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;找不到该值！&quot;)；</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-插入数据"><a href="#4-插入数据" class="headerlink" title="4.插入数据"></a>4.插入数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int Ins(sequenlist *L,int i,datatype b)</span><br><span class="line">&#123;</span><br><span class="line">int j;</span><br><span class="line">if(i&lt;1||i&gt;L-&gt;length)</span><br><span class="line">&#123;</span><br><span class="line">return FALSE;</span><br><span class="line">&#125;</span><br><span class="line">for(j&#x3D;L-&gt;length;j&gt;i;j--)</span><br><span class="line">&#123;</span><br><span class="line">L-&gt;elem[j]&#x3D;L-&gt;elem[j-1];</span><br><span class="line">&#125;</span><br><span class="line">L-&gt;elem[i+1]&#x3D;b;</span><br><span class="line">L-&gt;length++;</span><br><span class="line">return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-删除数据"><a href="#5-删除数据" class="headerlink" title="5.删除数据"></a>5.删除数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int Del(sequenlist *L,int i)</span><br><span class="line">&#123;</span><br><span class="line">\\删除顺序表L的第i个结点</span><br><span class="line">int j;</span><br><span class="line">if(i&lt;1||i&gt;L-length)</span><br><span class="line">&#123;</span><br><span class="line">return FALSE;</span><br><span class="line">&#125;</span><br><span class="line">for(j&#x3D;i;j&lt;L-&gt;length;j++)</span><br><span class="line">&#123;</span><br><span class="line">L-&gt;elem[j]&#x3D;L-&gt;elem[j+1];</span><br><span class="line">&#125;</span><br><span class="line">L-&gt;length--;</span><br><span class="line">return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完整例子"><a href="#完整例子" class="headerlink" title="完整例子"></a>完整例子</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;malloc.h&quot;</span><br><span class="line">#include &quot;stdlib.h&quot;</span><br><span class="line">#define maxsize 1024</span><br><span class="line">typedef char datatype;</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">datatype elem[maxsize];</span><br><span class="line">int last;&#x2F;&#x2F;表长</span><br><span class="line">&#125;sequenlist;</span><br><span class="line">&#x2F;&#x2F;在第i个元素前插入元素x</span><br><span class="line">int insert(sequenlist *L,datatype x,int i)</span><br><span class="line">&#123;</span><br><span class="line">int j;</span><br><span class="line">if(L-&gt;last&#x3D;&#x3D;maxsize-1)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;overflow!&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">else if(i&lt;0||i&gt;L-&gt;last)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;error , please input the right &#39;i&#39;&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    for(j&#x3D;L-&gt;last;j&gt;&#x3D;i;j--)</span><br><span class="line">    &#123;</span><br><span class="line">    L-&gt;elem[j+1]&#x3D;L-&gt;elem[j];printf(&quot;elem[%d]:%c\n&quot;,j+1,L-&gt;elem[j+1]);</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;elem[i]&#x3D;x;</span><br><span class="line">    L-&gt;last++;</span><br><span class="line">&#125;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;建立顺序表</span><br><span class="line">void creatlist(sequenlist *L)</span><br><span class="line">&#123;</span><br><span class="line">    int i,n;</span><br><span class="line">    char tmp;</span><br><span class="line">    printf(&quot;请输入数据个数：&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(i&#x3D;0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;elem[%d]:&quot;,i);</span><br><span class="line">        fflush(stdin);</span><br><span class="line">        scanf(&quot;%c&quot;,&amp;tmp);</span><br><span class="line">        L-&gt;elem[i]&#x3D;tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;last&#x3D;n-1;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void printout(sequenlist *L)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for(i&#x3D;0;i&lt;&#x3D;L-&gt;last;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;elem[%d]:&quot;,i);</span><br><span class="line">        printf(&quot;%c\n&quot;,L-&gt;elem[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int dellist(sequenlist *L,int i)</span><br><span class="line">&#123;</span><br><span class="line">    if(i&lt;0||i&gt;L-&gt;last)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;error , please input the right &#39;i&#39;&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        for(;i&lt;L-&gt;last;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            L-&gt;elem[i]&#x3D;L-&gt;elem[i+1];</span><br><span class="line">        &#125;</span><br><span class="line">        L-&gt;last--;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    sequenlist *L;</span><br><span class="line">    char cmd,x;</span><br><span class="line">    int i;</span><br><span class="line">    L&#x3D;(sequenlist *)malloc(sizeof(sequenlist));&#x2F;&#x2F;初始化</span><br><span class="line">    creatlist(L);</span><br><span class="line">    printout(L);</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;i,I...插入：\n&quot;);</span><br><span class="line">        printf(&quot;d,D...s删除\n&quot;);</span><br><span class="line">        printf(&quot;q，Q...退出\n&quot;);</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            fflush(stdin);</span><br><span class="line">            scanf(&quot;%c&quot;,&amp;cmd);</span><br><span class="line">        &#125; while (cmd!&#x3D;&#39;d&#39;&amp;&amp;cmd!&#x3D;&#39;D&#39;&amp;&amp;cmd!&#x3D;&#39;i&#39;&amp;&amp;cmd!&#x3D;&#39;I&#39;&amp;&amp;cmd!&#x3D;&#39;q&#39;&amp;&amp;cmd!&#x3D;&#39;Q&#39;);</span><br><span class="line">        switch(cmd)</span><br><span class="line">        &#123;</span><br><span class="line">            case &#39;i&#39;:</span><br><span class="line">            case &#39;I&#39;:printf(&quot;请输入你要插入的数据：&quot;);</span><br><span class="line">            fflush(stdin);</span><br><span class="line">            scanf(&quot;%c&quot;,&amp;x);</span><br><span class="line">            printf(&quot;请输入要插入的位置：&quot;);</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;i);</span><br><span class="line">            insert(L,x,i);</span><br><span class="line">            printout(L);break;</span><br><span class="line">            case &#39;d&#39;:</span><br><span class="line">            case &#39;D&#39;:</span><br><span class="line">            printf(&quot;请输入要删除元素的位置：&quot;);</span><br><span class="line">            fflush(stdin);</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;i);</span><br><span class="line">            dellist(L,i);</span><br><span class="line">            printout(L);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (cmd!&#x3D;&#39;q&#39;&amp;&amp;cmd!&#x3D;&#39;Q&#39;);</span><br><span class="line">    </span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>course</category>
      </categories>
      <tags>
        <tag>数据结构实验</tag>
      </tags>
  </entry>
  <entry>
    <title>线性链表</title>
    <url>/%E7%BA%BF%E6%80%A7%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<hr>
<h1 id="线性链表"><a href="#线性链表" class="headerlink" title="线性链表"></a>线性链表</h1><span id="more"></span>

<h2 id="一-单链表"><a href="#一-单链表" class="headerlink" title="一.单链表"></a>一.单链表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct Lnode</span><br><span class="line">&#123;</span><br><span class="line">ElemType data;</span><br><span class="line">Struct LNode *next;</span><br><span class="line">&#125;LinkList;</span><br><span class="line">LinkList *L,*head;</span><br></pre></td></tr></table></figure>

<h3 id="单链表的基本操作"><a href="#单链表的基本操作" class="headerlink" title="单链表的基本操作"></a>单链表的基本操作</h3><h4 id="1-清除链表的内容"><a href="#1-清除链表的内容" class="headerlink" title="1.清除链表的内容"></a>1.清除链表的内容</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int ClearList(LinkList *L)</span><br><span class="line">&#123;</span><br><span class="line">LinkList *temp;</span><br><span class="line">while(L-&gt;next!&#x3D;NULL)</span><br><span class="line">&#123;</span><br><span class="line">temp&#x3D;L-&gt;next</span><br><span class="line">L-&gt;next&#x3D;L-&gt;next-&gt;next;</span><br><span class="line">free(temp)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-求表长"><a href="#2-求表长" class="headerlink" title="2.求表长"></a>2.求表长</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int ListLength(LinkList *L)</span><br><span class="line">&#123;</span><br><span class="line">int len&#x3D;0;</span><br><span class="line">LinkList *temp;</span><br><span class="line">temp&#x3D;L;</span><br><span class="line">while(temp-&gt;next!&#x3D;NULL)</span><br><span class="line">&#123;</span><br><span class="line">len++;</span><br><span class="line">temp&#x3D;temp-&gt;next</span><br><span class="line">&#125;</span><br><span class="line">return len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-查找数据"><a href="#3-查找数据" class="headerlink" title="3.查找数据"></a>3.查找数据</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int Loc(LinkList *L, ElemType Item)</span><br><span class="line">&#123;</span><br><span class="line">	int i&#x3D; 1;</span><br><span class="line">	LinkList *temp;</span><br><span class="line">	temp &#x3D; L-&gt;next;</span><br><span class="line">	while (temp !&#x3D; NULL &amp;&amp; temp-&gt;data !&#x3D; Item)</span><br><span class="line">	&#123;</span><br><span class="line">		i++;</span><br><span class="line">		temp &#x3D; temp-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	if (temp &#x3D;&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		return i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-插入数据"><a href="#4-插入数据" class="headerlink" title="4.插入数据"></a>4.插入数据</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int Ins(LinkList *L, int i, ElemType Item)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;在单链表L的第i个位置后插入值为Item的数据</span><br><span class="line">	int j &#x3D; 1;</span><br><span class="line">	LinkList *node, *temp;</span><br><span class="line">	node &#x3D; (LinkList *)malloc(sizeof(LinkList));</span><br><span class="line">	if (node !&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	node-&gt;data &#x3D; Item;;</span><br><span class="line">	temp &#x3D; L-&gt;next;</span><br><span class="line">	if (temp &#x3D;&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		if (i &#x3D;&#x3D; 0)</span><br><span class="line">		&#123;</span><br><span class="line">			L-&gt;next &#x3D; node;</span><br><span class="line">			node-&gt;next &#x3D; NULL;</span><br><span class="line">			return 1;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;while (j &lt; i&amp;&amp;temp !&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		temp &#x3D; temp-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	if (temp &#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	node-&gt;next &#x3D; temp-&gt;next;</span><br><span class="line">	temp-&gt;next &#x3D; node;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>course</category>
      </categories>
      <tags>
        <tag>数据结构实验</tag>
      </tags>
  </entry>
  <entry>
    <title>顺序栈</title>
    <url>/%E9%A1%BA%E5%BA%8F%E6%A0%88/</url>
    <content><![CDATA[<hr>
<h1 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h1><span id="more"></span>

<p>c语言中用一维数组描述顺序栈中元素的存储区域。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define Maxsize 100</span><br><span class="line">typedef int datatype;</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">	datatype stack[Maxsize];</span><br><span class="line">	int top;</span><br><span class="line">&#125;SeqStack;</span><br><span class="line">SeqStack *s;</span><br></pre></td></tr></table></figure>

<h2 id="一-顺序栈的基本操作"><a href="#一-顺序栈的基本操作" class="headerlink" title="一.顺序栈的基本操作"></a>一.顺序栈的基本操作</h2><h3 id="1-构造一个空栈"><a href="#1-构造一个空栈" class="headerlink" title="1.构造一个空栈"></a>1.构造一个空栈</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SeqStack *InitStack()</span><br><span class="line">&#123;</span><br><span class="line">SeqStack *s;</span><br><span class="line">s&#x3D;(SeqStack *)malloc(sizeof(SeqStack));</span><br><span class="line">if(!s)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;空间不足&quot;)；</span><br><span class="line">reutrn NULL；</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">s-&gt;top&#x3D;-1;</span><br><span class="line">retuen s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-取栈顶元素"><a href="#2-取栈顶元素" class="headerlink" title="2.取栈顶元素"></a>2.取栈顶元素</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">datatype Gettop(SeqStack *s)</span><br><span class="line">&#123;</span><br><span class="line">	if (s-&gt;top &#x3D;&#x3D; -1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;\n栈是空的&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		return s-&gt;stack[s-&gt;top];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-入栈"><a href="#3-入栈" class="headerlink" title="3.入栈"></a>3.入栈</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SeqStack *Push(SeqStack *s,datatype x)</span><br><span class="line">&#123;</span><br><span class="line">if(s-&gt;top&#x3D;&#x3D;maxsize-1)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;\n栈满了！&quot;);</span><br><span class="line">retuen NULL;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">s-&gt;top++;</span><br><span class="line">s-&gt;stack[s-&gt;top]&#x3D;x;</span><br><span class="line">return s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-出栈"><a href="#4-出栈" class="headerlink" title="4.出栈"></a>4.出栈</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">datatype Pop(SeqStack *s)</span><br><span class="line">&#123;</span><br><span class="line">	if (s-&gt;top &#x3D;&#x3D; -1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;\nThe sequence stack is empty!&quot;);</span><br><span class="line">		return NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	s-&gt;top--;</span><br><span class="line">	return s-&gt;stack[s-&gt;top + 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-判别空栈"><a href="#5-判别空栈" class="headerlink" title="5.判别空栈"></a>5.判别空栈</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int StackEmpty(SeqStack *s)</span><br><span class="line">&#123;</span><br><span class="line">if(s-&gt;top&#x3D;&#x3D;-1)</span><br><span class="line">&#123;</span><br><span class="line">return TRUE;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">return FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-完整实例："><a href="#6-完整实例：" class="headerlink" title="6.完整实例："></a>6.完整实例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define Maxsize 50</span><br><span class="line">typedef int datatype;</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">	datatype stack[Maxsize];</span><br><span class="line">	int top;</span><br><span class="line">&#125;SeqStack;</span><br><span class="line">SeqStack *InitStack()</span><br><span class="line">&#123;</span><br><span class="line">	SeqStack *s;</span><br><span class="line">	s &#x3D; (SeqStack *)malloc(sizeof(SeqStack));</span><br><span class="line">	if (!s)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;空间不足&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		s-&gt;top &#x3D; -1;</span><br><span class="line">		return s;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">datatype Gettop(SeqStack *s)</span><br><span class="line">&#123;</span><br><span class="line">	if (s-&gt;top &#x3D;&#x3D; -1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;\n栈是空的&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		return s-&gt;stack[s-&gt;top];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">SeqStack *Push(SeqStack *s, datatype x)</span><br><span class="line">&#123;</span><br><span class="line">	if (s-&gt;top &#x3D;&#x3D; Maxsize - 1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;\n栈满了！&quot;);</span><br><span class="line">			return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		s-&gt;top++;</span><br><span class="line">		s-&gt;stack[s-&gt;top] &#x3D; x;</span><br><span class="line">		return s;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void display(SeqStack *s)</span><br><span class="line">&#123;</span><br><span class="line">	int t;</span><br><span class="line">	t &#x3D; s-&gt;top;</span><br><span class="line">	if (s-&gt;top &#x3D;&#x3D; -1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;The stack id empty\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		while (t !&#x3D; -1)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;%d-&gt;&quot;, s-&gt;stack[t]); t--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">datatype Pop(SeqStack *s)</span><br><span class="line">&#123;</span><br><span class="line">	if (s-&gt;top &#x3D;&#x3D; -1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;\nThe sequence stack is empty!&quot;);</span><br><span class="line">		return NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	s-&gt;top--;</span><br><span class="line">	return s-&gt;stack[s-&gt;top + 1];</span><br><span class="line">&#125;</span><br><span class="line">int StackEmpty(SeqStack *s)</span><br><span class="line">&#123;</span><br><span class="line">	if (s-&gt;top &#x3D;&#x3D; -1)</span><br><span class="line">	&#123;</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	int a[6] &#x3D; &#123; 3,7,4,12,31,15 &#125;, i;</span><br><span class="line">	SeqStack *p;</span><br><span class="line">	p &#x3D; InitStack();</span><br><span class="line">	for (i &#x3D; 0; i &lt; 6; i++)</span><br><span class="line">		Push(p, a[i]);</span><br><span class="line">	printf(&quot;output the stack values:&quot;);</span><br><span class="line">	display(p);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	printf(&quot;the stacktop value is:%d\n&quot;, Gettop(p));</span><br><span class="line">	Push(p, 100);</span><br><span class="line">	printf(&quot;output the stack values:&quot;);</span><br><span class="line">	display(p);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	printf(&quot;the stacktop value is:%d\n&quot;, Gettop(p));</span><br><span class="line">	Pop(p); Pop(p);</span><br><span class="line">	printf(&quot;the stacktop value is:%d\n&quot;, Gettop(p));</span><br><span class="line">	while(!StackEmpty(p))</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%4d&quot;, Pop(p));</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># define Maxsize 100</span><br><span class="line"># include&lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">typedef int datatype;</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">	int stack[Maxsize];</span><br><span class="line">	int top;</span><br><span class="line">&#125;SeqStack;</span><br><span class="line"></span><br><span class="line">SeqStack *InitStack()</span><br><span class="line">&#123;</span><br><span class="line">	SeqStack *S;</span><br><span class="line">	S &#x3D; (SeqStack *)malloc(sizeof(SeqStack));</span><br><span class="line">	if (!S)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;空间不足&quot;); return NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		S-&gt;top &#x3D; 0;</span><br><span class="line">		return S;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SeqStack *push(SeqStack *S, int x)</span><br><span class="line">&#123;</span><br><span class="line">	if (S-&gt;top &#x3D;&#x3D; Maxsize)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;the stack is overflow!\n&quot;);</span><br><span class="line">		return NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		S-&gt;stack[S-&gt;top] &#x3D; x;</span><br><span class="line">		S-&gt;top++;</span><br><span class="line">		return S;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int StackEmpty(SeqStack *S)</span><br><span class="line">&#123;</span><br><span class="line">	if (S-&gt;top &#x3D;&#x3D; 0)</span><br><span class="line">		return 1;</span><br><span class="line">	else</span><br><span class="line">		return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int pop(SeqStack *S)</span><br><span class="line">&#123;</span><br><span class="line">	int y;</span><br><span class="line">	if (S-&gt;top &#x3D;&#x3D; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;the stack is empty!\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		S-&gt;top--;</span><br><span class="line">		y &#x3D; S-&gt;stack[S-&gt;top];</span><br><span class="line">		return y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void conversion(int N, int R)</span><br><span class="line">&#123;</span><br><span class="line">	int x &#x3D; N, y &#x3D; R;</span><br><span class="line">	SeqStack *S;</span><br><span class="line">	S &#x3D; InitStack();</span><br><span class="line">	while (N !&#x3D; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		push(S, N%R);</span><br><span class="line">		N &#x3D; N &#x2F; R;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n十进制数%d所对应的%d进制数是：&quot;, x, y);</span><br><span class="line">	while (!StackEmpty(S))</span><br><span class="line">		printf(&quot;%d&quot;, pop(S));</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n, r;</span><br><span class="line">	printf(&quot;请输入任意一个十进制整数及其所需转换的二至九间的任一进制数：\n&quot;);</span><br><span class="line">	scanf(&quot;%d,%d&quot;, &amp;n, &amp;r);</span><br><span class="line">	conversion(n, r);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>course</category>
      </categories>
      <tags>
        <tag>数据结构实验</tag>
      </tags>
  </entry>
  <entry>
    <title>链栈</title>
    <url>/%E9%93%BE%E6%A0%88/</url>
    <content><![CDATA[<hr>
<h1 id="栈链"><a href="#栈链" class="headerlink" title="栈链"></a>栈链</h1><span id="more"></span>

<h2 id="链栈的定义类型"><a href="#链栈的定义类型" class="headerlink" title="链栈的定义类型"></a>链栈的定义类型</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct node</span><br><span class="line">&#123;</span><br><span class="line">datatype data;</span><br><span class="line">struct node *next;</span><br><span class="line">&#125;Linkstack;</span><br><span class="line">Linkstack *top;</span><br></pre></td></tr></table></figure>

<h2 id="1-判别栈空"><a href="#1-判别栈空" class="headerlink" title="1.判别栈空"></a>1.判别栈空</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int Stackempty(Linkstack *top)</span><br><span class="line">&#123;</span><br><span class="line">	return top ? 0 : 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-取栈顶元素"><a href="#2-取栈顶元素" class="headerlink" title="2.取栈顶元素"></a>2.取栈顶元素</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">datatype Gettop(Linkstack *top)</span><br><span class="line">&#123;</span><br><span class="line">	if (!top)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;\n栈链是空的&quot;);</span><br><span class="line">			return 0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-入栈"><a href="#3-入栈" class="headerlink" title="3.入栈"></a>3.入栈</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Linkstack *Push(Linkstack *top, datatype x)</span><br><span class="line">&#123;</span><br><span class="line">	Linkstack *p;</span><br><span class="line">	p &#x3D; (Linkstack *)malloc(sizeof(Linkstack));</span><br><span class="line">	p-&gt;data &#x3D; x;</span><br><span class="line">	p-&gt;next &#x3D; top;</span><br><span class="line">	top &#x3D;&#x3D; p;</span><br><span class="line">	return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-出栈"><a href="#4-出栈" class="headerlink" title="4.出栈"></a>4.出栈</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Linkstack *Pop(Linkstack *top)</span><br><span class="line">&#123;</span><br><span class="line">	Linkstack *p;</span><br><span class="line">	if (!top)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;\n栈是空的&quot;); return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	p &#x3D; top;</span><br><span class="line">	top &#x3D; top-&gt;next;</span><br><span class="line">	free(p);</span><br><span class="line">	return top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>course</category>
      </categories>
      <tags>
        <tag>数据结构实验</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown-3</title>
    <url>/markdown-3/</url>
    <content><![CDATA[<hr>
<center><b>你好，Typora</b></center>

<span id="more"></span>

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=420 height=86 src="//music.163.com/outchain/player?type=2&id=1823305772&auto=0&height=66"></iframe>

<h2 id="1-Typora是目前最受欢迎的Markdown编辑器之一。它的主要特性如下。"><a href="#1-Typora是目前最受欢迎的Markdown编辑器之一。它的主要特性如下。" class="headerlink" title="1.Typora是目前最受欢迎的Markdown编辑器之一。它的主要特性如下。"></a>1.Typora是目前最受欢迎的Markdown编辑器之一。它的主要特性如下。</h2><p>1）实时预览：传统的Markdown编辑器都有两个窗口，左边是源码，右边是渲染后的效果。Typora独辟蹊径，把源码编辑和效果预览合二为一，实现了真正的所见即所得。</p>
<p>2）扩展语法：Typora不光支持GFM，还扩展了数学公式、流程图等功能。</p>
<p>3）快捷操作：Typora对几乎所有的Markdown标记都提供了快捷操作方式，使用起来非常高效。</p>
<p>4）界面漂亮：默认支持6种主题，可自定义，好看又好用。</p>
<p>5）文件转换：支持多种文件格式通过导入/导出功能跟.md格式相互转换。</p>
<p>6）支持中文：支持中文，可以帮助大家更好地理解各项功能。</p>
<p>7）视图模式：支持大纲和文档列表视图，方便在不同段落和不同文件之间进行切换。</p>
<p>8）跨平台：支持macOS、Windows和Linux系统。</p>
<p>9）目前免费：这么好用的编辑器竟然是<strong>免费</strong>的。</p>
<h2 id="2-界面概览"><a href="#2-界面概览" class="headerlink" title="2.界面概览"></a>2.界面概览</h2><p>先来认识一下Typora编辑器的界面，如下图所示。</p>
<img src="https://i.loli.net/2021/03/17/hfPFW2uyLTGqRCV.png" alt="image-20210221225234240" style="zoom: 50%;" />

<h2 id="3-字数统计"><a href="#3-字数统计" class="headerlink" title="3.字数统计"></a>3.字数统计</h2><p>把鼠标放到状态栏上，在右下角会显示文件的字数，单击字数会显示较详细的字数信息。如果你选择了一段文本，则会在信息面板中显示被选中的文字信息。<br>默认鼠标放到状态栏上才会显示字数信息，如果我们想让字数一直显示，则需要在【偏好设置】中设置，操作步骤：文件→【偏好设置】→【字数统计→勾选【总是显示字数统计】</p>
<h2 id="４-主题"><a href="#４-主题" class="headerlink" title="４.主题"></a>４.主题</h2><p>Typora提供了6款漂亮的主题供大家选择，每一个都很漂亮。可通过菜单栏上的【主题】进行切换，主题效果示例如下。</p>
<img src="https://i.loli.net/2021/02/22/iWo9QbYaBORj8eJ.png" alt="image-20210221225358730" style="zoom: 50%;" />

<h2 id="５-实时预览"><a href="#５-实时预览" class="headerlink" title="５.实时预览"></a>５.实时预览</h2><p>Typora编辑器最具特色的功能是实时预览，当输入Markdown标记后，按回车键或把光标定位到别的段落就能够看到预览效果。</p>
<p><img src="https://i.loli.net/2021/02/22/lSFdOtoW8GZMY6I.png" alt="image-20210221225453060" style="zoom: 50%;" /><img src="https://i.loli.net/2021/02/22/KoVpm2PwGv7txSR.png" alt="image-20210221225512568" style="zoom:50%;" /></p>
<img src="https://i.loli.net/2021/02/22/vZGjOwlsF9eCApK.png" alt="image-20210221225535733" style="zoom: 50%;" />

<h2 id="6-安装Pandoc"><a href="#6-安装Pandoc" class="headerlink" title="6.安装Pandoc"></a>6.安装Pandoc</h2><p>Pandoc是一个标记语言转换工具，可实现不同标记语言间的格式转换。<br>Typora的文件导入/导出功能是使用Pandoc把Markdown文件转换成不同格式的文件，所以如果想使用文件导入/导出功能，必须要先安装Pandoc。<br>如果不安装Pandoc，Typora只支持导出HTML和PDF格式的文件。<br>如果安装了Pandoc，Typora支持的文件格式如下。<br>· 导入文件格式。<br>如.docx、.latex、.tex、.ltx，.rst、.rest、.org、.wiki、.dokuwiki、.textile、.opml、.epub等。<br>· 导出文件格式。<br>如HTML、PDF、Word、OpenOffice、RTF、ePub、LA<br> TEX、MediaWiki、PNG等。<br>Pandoc的安装步骤如下。<br>打开<a href="https://github.com/jgm/pandoc/releases/latest%EF%BC%8C%E4%B8%8B%E8%BD%BD%E6%9C%80%E6%96%B0%E7%9A%84%E5%AE%89%E8%A3%85%E5%8C%85%EF%BC%88%E6%B3%A8%E6%84%8F%E8%A6%81%E5%AF%B9%E5%BA%94%E6%9C%AC%E6%9C%BA%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%89%EF%BC%8C%E5%8F%8C%E5%87%BB%E5%90%8E%E6%8C%89%E7%85%A7%E6%8F%90%E7%A4%BA%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%AE%89%E8%A3%85%E5%8D%B3%E5%8F%AF%E3%80%82">https://github.com/jgm/pandoc/releases/latest，下载最新的安装包（注意要对应本机的操作系统），双击后按照提示一步一步安装即可。</a><br>macOS用户还可以使用home-brew进行安装。</p>
<h2 id="7-高效地使用Markdown"><a href="#7-高效地使用Markdown" class="headerlink" title="7.高效地使用Markdown"></a>7.高效地使用Markdown</h2><p>Typora支持GFM，还扩展了很多其他的功能（如支持数学公式、上标、下标、高亮、各种图表等），它几乎为每一种标记都提供了快捷的操作方式，并且通过最佳实践规避了一些令人困惑的操作，这使我们的写作变得更加轻松。</p>
<h2 id="8-基础语法和GFM语法"><a href="#8-基础语法和GFM语法" class="headerlink" title="8.基础语法和GFM语法"></a>8.基础语法和GFM语法</h2><p><strong>编辑段落:</strong></p>
<p>在Typora中通过执行：菜单栏→【段落】→【段落/引用/表格/代码块/分隔线/有序列表/无序列表/任务列表】，可以添加或移除关于段落的标记符号。<br>a）段落与换行<br>在Markdown中，换行符是比较让人困惑的，对此，Typora的官方建议如下。<br>1）使用Typora的默认设置。<br>2）在Typora混合界面（预览界面）写作。<br>3）使用Enter键插入新段落，避免多插入空行。<br>4）如果要插入强制换行符，请使用HTML标签<br/>。<br>最通用的插入强制换行符的方法有两种。<br>1）在行尾加两个空格然后按回车键。<br>2）使用HTML标签<br/>实现换行，在默认情况下，<br/>不显示，若想显示可以执行：菜单栏→【编辑】→【空格与换行】→勾选【显示<br/>】。<br>在Typora中，还提供了一种快速换行的方法，确认勾选保留单换行符：菜单栏→【编辑】→【空格与换行】→勾选【保留单换行符】，然后使用快捷键Shift+Enter换行。<br>上述换行符可能在导出/打印时被忽略，请到【偏好设置】→【空格与换行】→【导出/打印】去设置是否忽略。</p>
<p><strong>关于Typora中的段落需要知道下面几点内容:</strong><br>1）如果想要开始新的段落只需按一次回车键即可，所见即所得，查看源码你会发现Typora自动帮我们插入了一个空行。<br>2）在默认情况下，段落的首行没有缩进，但如果你习惯了首行缩进，可以这样设置：菜单栏→【编辑】→【空格与换行】→勾选【首行缩进】。<br>3）在表格或图表的前后插入段落不太方便，如果有此需求，可以在表格内单击鼠标右键→【插入】→选择【段落（上方）/段落（下方）】。</p>
<h3 id="1-编辑样式"><a href="#1-编辑样式" class="headerlink" title="1. 编辑样式"></a>1. 编辑样式</h3><p>在Typora中通过执行：菜单栏→【格式】→【加粗/斜体/代码（行内代码）/图像/超链接】可以添加或移除关于文字样式<br> 的标记符号。如果没有选中文字，则只会添加标记符号；如果选中了文字，则会为选中的文字添加或移除标记符号。<br>相关样式的快捷键如下。</p>
<img src="https://i.loli.net/2021/02/22/d6Z1YRqukbBS4Wy.png" alt="image-20210221225744873" style="zoom: 50%;" />

<h3 id="2-标题设置"><a href="#2-标题设置" class="headerlink" title="2. 标题设置"></a>2. 标题设置</h3><p><strong>对标题进行设置的快捷键如下:</strong></p>
<img src="https://i.loli.net/2021/02/22/E16wjuFhPSHJtX4.png" alt="image-20210221230622903" style="zoom: 50%;" />

<p><strong>小提示：</strong><br> 当标题的级别过多时，除了查看源码，肉眼很难区分它们，有没有什么办法可以更好地区分标题的级别呢?有，把光标放在标题行的任意位置，在标题行的左上角会显示标题的级别（h3/h4/h5），一级和二级标题不显示。</p>
<h3 id="3-列表设置"><a href="#3-列表设置" class="headerlink" title="3. 列表设置"></a>3. 列表设置</h3><p>Typora支持有序列表、无序列表和任务列表，它们之间可以通过快捷键实现快速切换，还可以使用列表缩进功能快速调整缩进，使用起来非常方便。与列表操作相关的快捷键如下表所示:</p>
<img src="https://i.loli.net/2021/02/22/goiqYI2UvC7xEOs.png" alt="image-20210221230804645" style="zoom: 50%;" />

<p><strong>小提示:</strong><br>1）当光标放在任务列表上时，任务状态被激活，这时才可以“切换任务状态”。<br>2）列表和代码块都可以使用“增加缩进”和“减少缩进”。<br>效果如下图所示:</p>
<img src="https://i.loli.net/2021/02/22/8ZI7xlHwheOjzcP.png" alt="image-20210221231012999" style="zoom: 50%;" />

<h3 id="4-引用和水平分隔线"><a href="#4-引用和水平分隔线" class="headerlink" title="4. 引用和水平分隔线"></a>4. 引用和水平分隔线</h3><p>与引用和水平分割线相关的快捷键如下:</p>
<img src="https://i.loli.net/2021/02/22/EOaILm5oBKYCVt3.png" alt="image-20210221231637492" style="zoom: 50%;" />

<h3 id="5-创建表格"><a href="#5-创建表格" class="headerlink" title="5.创建表格"></a>5.创建表格</h3><p>如果想创建一个表格，可以执行：菜单栏→【段落】→【表格】→输入列数和行数→单击【确定】按钮。创建表格的快捷键如下。</p>
<img src="https://i.loli.net/2021/02/22/uhWOwCSe4qDYvVa.png" alt="image-20210221231746145" style="zoom: 50%;" />

<p>除上面所讲的方法外，还有一种可以快速创建表格的比较酷的方式：输入表头的标记语法，在最后一个|之后按回车键。</p>
<h4 id="a-增加行-删除行、复制表格、格式化表格"><a href="#a-增加行-删除行、复制表格、格式化表格" class="headerlink" title="a)增加行/删除行、复制表格、格式化表格:"></a>a)<strong>增加行/删除行、复制表格、格式化表格:</strong></h4><p>​    对于表格的增加、删除、复制和格式化操作，可以在表格中单击鼠标右键，选择【表格】，通过其列出的操作选项对表格进行操作，如下图所示:</p>
<img src="https://i.loli.net/2021/02/22/qbFNjKQGeEncaRZ.png" alt="image-20210221233312913" style="zoom:50%;" />

<p><strong>相关快捷键如下:</strong></p>
<img src="https://i.loli.net/2021/02/22/ZXz8qtxNMpYnFAK.png" alt="image-20210221233437566" style="zoom:50%;" />

<h4 id="b-快速调整表格"><a href="#b-快速调整表格" class="headerlink" title="b)快速调整表格:"></a>b)<strong>快速调整表格:</strong></h4><p>如果想快速调整表格的行数、列数、对齐方式，可以将光标放在表格中，表格左上方和右上方都会显示操作菜单，直接进行操作即可，如下所示:</p>
<img src="https://i.loli.net/2021/02/22/YzDqFoSTEaQx9Z4.png" alt="image-20210221233536647" style="zoom:50%;" />

<p>如果想调整表格中行或列的顺序，可将光标放在行的最左边或列的最上边，待光标变成双向箭头后拖动即可调整顺序，如下图所示:</p>
<img src="https://i.loli.net/2021/02/22/ukpNn8i6xoYy3s7.png" alt="image-20210221233610573" style="zoom:50%;" />

<h3 id="6-插入围栏代码块"><a href="#6-插入围栏代码块" class="headerlink" title="6.插入围栏代码块"></a>6.插入围栏代码块</h3><p>如果想添加或删除围栏代码块的标记，可以执行：菜单栏→【段落】→【代码块】。如果想把某段内容使用围栏代码块包裹，需要先选中该内容，然后执行上述操作。<br>相关快捷键如下:</p>
<img src="https://i.loli.net/2021/02/22/8NZESep2lnDCkIy.png" alt="image-20210221233806480" style="zoom:67%;" />

<p><strong>如果想声明语言，将光标放在代码块中，在代码块右下角的【选择语言】中输入编程语言就可以了。</strong></p>
<ol>
<li>显示代码行数。<br> 代码块默认是不显示代码行数的，如果想显示，则需要执行：文件→【偏好设置】→【代码块】→勾选【显示行号】。</li>
<li>自动换行。<br> 在代码块中，如果代码过长，默认是会自动换行的，如果我们不希望代码自动换行，可以执行：文件→【偏好设置】→【代码块】→不勾选【代码块自动换行】。</li>
</ol>
<h2 id="Typora扩展语法"><a href="#Typora扩展语法" class="headerlink" title="Typora扩展语法"></a>Typora扩展语法</h2><p>Typora扩展了下画线、数学公式、目录、脚注、上标和下标、图表操作等功能，并且支持很多HTML标签，使排版格式变得更加齐全。</p>
<h3 id="1-编辑样式-1"><a href="#1-编辑样式-1" class="headerlink" title="1.编辑样式"></a>1.编辑样式</h3><h4 id="a）下画线"><a href="#a）下画线" class="headerlink" title="a）下画线"></a>a）下画线</h4><p>在Typora中，下画线是通过HTML的<u>标签实现的，其语法如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;u&gt;这段文字由下划线&lt;u&gt;</span><br></pre></td></tr></table></figure>

<p>示例:</p>
<p><u>这段文字由下划线</u>  </p>
<p>相关快捷键如下:</p>
<img src="https://i.loli.net/2021/02/22/vYmFkOS7GhUtape.png" alt="image-20210221234520890" style="zoom:50%;" />

<h4 id="b）内联数学公式"><a href="#b）内联数学公式" class="headerlink" title="b）内联数学公式"></a>b）内联数学公式</h4><p>如果想使用内联数学公式，需要先激活：【偏好设置】→【Markdown扩展语法】→勾选【内联公式】→重启Typora，内联数学公式的语法是使用$把数学公式包裹起来，如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$数学公式$</span><br></pre></td></tr></table></figure>

<p>实例演示如下:</p>
<img src="https://i.loli.net/2021/02/22/cCHvuWDZxfpmK7T.png" alt="image-20210221234655883" style="zoom:50%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">分数:$f(x,y)&#x3D;\frac&#123;x^2&#125;&#123;y^3&#125;$</span><br><span class="line"></span><br><span class="line">开根号:$f(x,y)&#x3D;\sqrt[n]&#123;&#123;x^2&#125;&#123;y^3&#125;&#125;$</span><br><span class="line"></span><br><span class="line">省略号:$f(x_1,y_2,\ldots,x_n)&#x3D;x_1+X_2+\cdots+x_n$</span><br></pre></td></tr></table></figure>

<p>设置内联数学公式的快捷键如下:</p>
<p><img src="https://i.loli.net/2021/03/17/PaCBKUDdo2e6LN7.png" alt="image-20210221235156119"></p>
<h4 id="c）下标和上标"><a href="#c）下标和上标" class="headerlink" title="c）下标和上标"></a>c）下标和上标</h4><p>如果想使用上标和下标，需要先激活：【偏好设置】→【Markdown扩展语法】→勾选【下标】、【上标】→重启Typora，其语法如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A~下标~</span><br><span class="line">A^上标^</span><br></pre></td></tr></table></figure>

<p>示例:</p>
<p><strong>A<del>上标</del><br>A^下标^</strong></p>
<p>语法说明如下。<br>1）使用~把下标内容包裹起来。<br>2）使用^把上标内容包裹起来。</p>
<h4 id="d）高亮"><a href="#d）高亮" class="headerlink" title="d）高亮"></a>d）高亮</h4><p>如果想使用高亮功能，需要先激活：【偏好设置】→【Markdown扩展语法】→勾选【高亮】→重启Typora，其语法如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;高亮&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>

<p>示例:</p>
<p>==高亮==</p>
<p>语法说明如下:<br>1）使用两个等号（=）把想要高亮的内容包裹起来。<br>2）设置为高亮的内容显示为黄色。</p>
<p>设置高亮效果的快捷键如下:</p>
<img src="https://i.loli.net/2021/02/25/srEPvhC9zA8L3Gn.png" alt="image-20210221235953022" style="zoom:50%;" />

<p>e）注释<br>如果想添加注释，可以执行：菜单栏→【格式】→【注释】。在编辑和预览时，注释的内容会被显示；在导出PDF或Word时，则会被隐藏。<br>设置注释的语法如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--注释--&gt;</span><br></pre></td></tr></table></figure>

<p>示例:</p>
<!--注释-->



<p>设置注释的快捷键如下:</p>
<img src="https://i.loli.net/2021/02/25/srEPvhC9zA8L3Gn.png" alt="image-20210222000222918" style="zoom:50%;" />

<h4 id="f）清除样式"><a href="#f）清除样式" class="headerlink" title="f）清除样式"></a>f）清除样式</h4><p>如果想快速清除样式，可以执行：菜单栏→【格式】→【清除样式】。<br>清除样式的快捷键如下:</p>
<img src="https://i.loli.net/2021/02/25/jWoXMRTH6nIisAD.png" alt="image-20210222000259588" style="zoom:50%;" />

<h3 id="2-编辑段落"><a href="#2-编辑段落" class="headerlink" title="2.编辑段落"></a>2.编辑段落</h3><h4 id="a）数学公式块"><a href="#a）数学公式块" class="headerlink" title="a）数学公式块"></a>a）数学公式块</h4><p>专业的写作离不开数学公式，Typora对此做了很好的支持，其语法是使用两个$包裹数学公式，如下所示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">数学公式</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>

<p>示例:<br>$$<br>数学公式<br>$$<br>为某段内容添加或删除公式块，需要先选中该内容，然后执行：菜单栏→【段落】→【公式块】。如果不选中任何内容，直接执行：菜单栏→【段落】→【公式块】，则会插入公式块标记。<br>公式块快捷键如下:</p>
<img src="https://i.loli.net/2021/02/25/ukQ7M9hR5NFBx3y.png" alt="image-20210222000550136" style="zoom:50%;" />

<h4 id="b）目录"><a href="#b）目录" class="headerlink" title="b）目录"></a>b）目录</h4><p>在Typora中，可以自动获取文章的标题来生成目录，当标题修改时，目录会随之自动更新，使用起来非常方便，其语法如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[TOC]</span><br></pre></td></tr></table></figure>

<p>示例:</p>
<p>本目录</p>
<p>语法说明如下。<br>1）TOC是Table of Contents的缩写。<br>2）在想插入目录的位置输入[TOC]，按回车键后就可以自动生成文章的目录了。<br>直接输入[TOC]标记已经很简便了，可如果我们忘记了语法，也可以执行：菜单栏→【段落】→【内容目录】。</p>
<h4 id="c）脚注"><a href="#c）脚注" class="headerlink" title="c）脚注"></a>c）脚注</h4><p>添加脚注的语法如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">脚注[^参考]</span><br><span class="line">[^脚注]:对脚注的描述</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<p>脚注<a href="%E5%AF%B9%E8%84%9A%E6%B3%A8%E7%9A%84%E6%8F%8F%E8%BF%B0">^参考</a></p>
<p>插入脚注的快捷键如下：</p>
<p><img src="https://i.loli.net/2021/03/17/XSocNwDVOjZAzGd.png" alt="image-20210225211138538"></p>
<h4 id="d）图表（序列图、流程图和Mermaid）"><a href="#d）图表（序列图、流程图和Mermaid）" class="headerlink" title="d）图表（序列图、流程图和Mermaid）"></a>d）图表（序列图、流程图和Mermaid）</h4><p>如果想使用图表功能，需要先激活：文件→【偏好设置】→【Markdown扩展语法】→勾选【图表】→重启Typora。<br>需要注意如下几点。<br>1）图表是Typora的扩展语法，标准的Markdown语法、CommonMark和GFM都不支持这一语法。<br>2）如果想要把图表使用到更多的地方，推荐直接插入图片，不推荐在Typora中进行绘制。<br>3）在Typora中，图表在导出HTML/PDF/ePub/docx等格式的文件时会被正常显示，但是其他的Markdown编辑器不一定支持此语法。</p>
<ul>
<li><blockquote>
<p> <strong>序列图</strong><br> <strong>序列图</strong>（<strong>Sequence</strong> <strong>Diagram</strong>）<strong>也被称为循序图</strong>，<strong>是一种UML（Unified Modeling Language，统一建模语言）行为图，它通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作。</strong></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">​&#96;&#96;&#96;sequence</span><br><span class="line">js-sequence-diagrams</span><br><span class="line">​&#96;&#96;&#96;</span><br></pre></td></tr></table></figure>

<p> 语法说明如下。<br> 1）使用3个`+sequence包裹js-sequence-diagrams语法。<br> 2）js-sequence-diagrams语法参考<a href="https://bramp.github.io/js-sequence-diagrams/%E3%80%82">https://bramp.github.io/js-sequence-diagrams/。</a><br> 实例演示如下。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">张三-&gt;李四:吃了吗？</span><br><span class="line">Note right of 李四:我显示在张李四右边</span><br><span class="line">李四--&gt;张三:好久不见</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><blockquote>
<p>· <strong>流程图</strong><br><strong>流程图是以图像的方式表示过程、算法和流程的，Typora提供的流程图语法标记是基于开源项目（flowchart.js）开发的，其语法如下</strong>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">​&#96;&#96;&#96;flow</span><br><span class="line">flowchart.js语法</span><br><span class="line">​&#96;&#96;&#96;</span><br></pre></td></tr></table></figure>

<p>语法说明如下。<br>1）使用3个`+flow包裹flowchart.js语法。<br>2）flowchart.js语法参考<a href="http://flowchart.js.org/%E3%80%82">http://flowchart.js.org/。</a><br>实例演示如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">op&#x3D;&gt;operation: 我是帅哥?</span><br><span class="line">cond&#x3D;&gt;condition: yes or no?</span><br><span class="line">e&#x3D;&gt;end: 结束</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><blockquote>
<p><strong>Mermaid</strong><br><strong>Typora集成了Mermaid，Mermaid支持使用文本的方式生成图表，包括序</strong></p>
<p><strong>列图、流程图和甘特图。</strong><br><strong>1）Mermaid序列图的语法如下（可参考</strong><a href="https://knsv.github.io/mermaid/#loops32%EF%BC%89%E3%80%82">https://knsv.github.io/mermaid/#loops32）。</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">​&#96;&#96;&#96;mermaid</span><br><span class="line">mermaid序列图语法</span><br><span class="line">​&#96;&#96;&#96;</span><br></pre></td></tr></table></figure>

<p>示例如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%% 注释</span><br><span class="line">sequenceDiagram</span><br><span class="line">张三-&gt;李四:吃了吗？</span><br><span class="line">Note right of 李四:我显示在张李四右边</span><br><span class="line">李四--&gt;张三:好久不见</span><br></pre></td></tr></table></figure>

<p><strong>2）Mermaid流程图的语法如下（可参考<a href="https://knsv.github.io/mermaid/#graph18%EF%BC%89%E3%80%82">https://knsv.github.io/mermaid/#graph18）。</a></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">​&#96;&#96;&#96;mermaid</span><br><span class="line">mermaid流程图语法</span><br><span class="line">​&#96;&#96;&#96;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[开始]--&gt;B(我是帅哥)</span><br><span class="line">B--&gt;C(yes or no)</span><br><span class="line">C--&gt;|Yes|D(结束)</span><br><span class="line">C--&gt;|No|B</span><br></pre></td></tr></table></figure>

<p><strong>3）Mermaid甘特图。</strong><br><strong>甘特图（Gantt chart）是将活动与时间联系起来的一种图表形式，能够显示每个活动的历时长短。甘特图很清晰地标识出每一项任务的起始与结束时间，通常在项目管理中使用，方便人们从时间上整体把握项目进度。</strong><br><strong>Mermaid甘特图的语法如下（可参考<a href="http://knsv.github.io/mermaid/index.html#mermaid-cli%EF%BC%89%E3%80%82">http://knsv.github.io/mermaid/index.html#mermaid-cli）。</a></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">​&#96;&#96;&#96;mermaid</span><br><span class="line">mermaid甘特图语法</span><br><span class="line">​&#96;&#96;&#96;</span><br></pre></td></tr></table></figure>

<p>示例如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gantt</span><br><span class="line">dateFormat YYYY-MM-DD</span><br><span class="line">	title 项目开发周期</span><br><span class="line">	section 需求评审</span><br><span class="line">	需求评审	:2018-01-01,2018-01-02</span><br><span class="line">	section 功能开发</span><br><span class="line">	开发编码	:2018-01-03,2018-01-09</span><br><span class="line">	开发自测	:2018-01-08,2018-01-09</span><br><span class="line">	section 项目测试</span><br><span class="line">	第一轮测试	:2018-01-09,2018-01-14</span><br><span class="line">	第二轮测试	:2018-01-14,2018-01-16</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h3 id="3-使用HTML标签"><a href="#3-使用HTML标签" class="headerlink" title="3.使用HTML标签"></a>3.使用HTML标签</h3><p><strong>Typora还支持很多常用的HTML标签，使用这些标签可以让样式更加丰富，但这也导致纯粹的写作变得更加复杂，提高了用户使用的门槛，因此我们在此只列举几个简单的例子作为参考。</strong></p>
<h4 id="a）文字颜色和大小"><a href="#a）文字颜色和大小" class="headerlink" title="a）文字颜色和大小"></a>a）文字颜色和大小</h4><p>示例代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">推荐使用样式给文字添加颜色</span><br><span class="line">&lt;span style&#x3D;&quot;color:green&quot;&gt; 绿色 &lt;&#x2F;span&gt;&lt;span style&#x3D;&quot;color:#fa0;font-size:20px&quot;&gt;黄色&lt;&#x2F;span&gt;&lt;span style&#x3D;&quot;color:red;font-size:30px&quot;&gt;红色&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>

<p>示例推荐使用样式给文字添加颜色<br><span style="color:green"> 绿色 </span><span style="color:#fa0;font-size:20px">黄色</span><span style="color:red;font-size:30px">红色</span></p>
<h4 id="b）嵌入网页"><a href="#b）嵌入网页" class="headerlink" title="b）嵌入网页"></a>b）嵌入网页</h4><p>示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;iframe height&#x3D;&#39;265&#39;	scrolling&#x3D;&#39;yes&#39;	title&#x3D;&#39;百 度 首 页&#39;src&#x3D;&#39;http:&#x2F;&#x2F;www.baidu.com&#39; frameborder&#x3D;&#39;no&#39; allowtransparemcy&#x3D;&#39;ture&#39; allowfullscreen&#x3D;&#39;true&#39; style&#x3D;&#39;width:100%&#39;&gt;&lt;&#x2F;iframe&gt;e&gt;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<iframe height='265'    scrolling='yes'    title='百 度 首 页'src='http://www.baidu.com' frameborder='no' allowtransparemcy='ture' allowfullscreen='true' style='width:100%'></iframe>

<p>注意：<br> 内嵌的网页在导出文件时是无法显示的。</p>
<h4 id="c）插入视频"><a href="#c）插入视频" class="headerlink" title="c）插入视频"></a>c）插入视频</h4><p>示例代码如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;video src&#x3D;&quot;.imgs&#x2F;video.mov&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;video src=&quot;路径&quot;/&gt;</code></p>
<p> 内嵌的视频在导出文件时是无法显示的。<br>这些标签的使用专业要求相对较高，不适合普通读者，感兴趣的读者可以到<a href="https://support.typora.io/HTML/%E4%BA%86%E8%A7%A3%E6%9B%B4%E5%A4%9A%E3%80%82">https://support.typora.io/HTML/了解更多。</a></p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
</search>
